

  float islandJungle(vec2 u) {
    vec2 pos = vec2(0.5)-u;
    vec3 p = vec3(-90.5+sin(time*0.3));

    // bottom-left
    vec2 bl = smoothstep(vec2(0.1),1.0-u, u);
    float pct = bl.x * bl.y;

    // top-right
    // vec2 tr = step(vec2(0.1),1.0-st);
    // pct *= tr.x * tr.y;

    color = vec3(pct);

    float ap = pos.x*sin(p.z*pct);
    float qap = ap+sin(ap*p.z);
    float fap = fract(qap);
    float azp = pos.y*p.z;
    float asp = cos(sin(azp));
    float afp = atan(tan(asp*qap), azp*asp);
    float atp = pos.x*tan(p.z*sin(pct));
    float r = length(pos)*2.0;
    float a = atan(pos.y, atp);
    a = atan(azp, fap);
    a = atan((azp), afp);
    a = atan((azp), cos(afp+fap));
    float b = atan(pos.y, atp+sin(fap));
    
    float ofc = 17.;

    float ft = fract(cos(a*12.5*b));
    float fb = abs(cos(a*3.));
    float fbs = abs(sin(fb*a));
    float fbc = fb + fbs;
    float fab = abs(cos(a*3.));
    float fsb = abs(cos(a*ofc*sin(a)));
    float fpc =pow(fab, 2.0);
    // a = c;
    // f = fb + fbs;
    float f = cos(a*3.);
    f = fab;
    float fh = fpc +fsb;
    fh = fab * qap + fh;
    f = fh;
    f = abs(cos(a*2.5)*cos(b))*ft*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.+cos(time))*sin(time +a))*.8+.1;
    // f = (fbc)+smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

    float s =  1.-smoothstep(f,f+0.02,r);
    vec3 island = vec3(s*fap, s*ft, b*s);
    return island;
  }

  float redLakes(vec2 u) {
    vec2 pos = vec2(0.5)-u;
    vec3 p = vec3(-90.5+sin(time*0.3));

    // bottom-left
    vec2 bl = smoothstep(vec2(0.1),1.0-u, u);
    float pct = bl.x * bl.y;

    // top-right
    // vec2 tr = step(vec2(0.1),1.0-st);
    // pct *= tr.x * tr.y;

    color = vec3(pct);

    float ap = pos.x*sin(p.z*pct);
    float qap = ap+sin(ap*p.z);
    float fap = fract(qap);
    float azp = pos.y*p.z;
    float asp = cos(sin(azp));
    float afp = atan(tan(asp*qap), azp*asp);
    float atp = pos.x*tan(p.z*sin(pct));
    float r = length(pos)*2.0;
    float a = atan(pos.y, atp);
    a = atan(azp, fap);
    a = atan((azp), afp);
    a = atan((azp), cos(afp+fap));
    float b = atan(pos.y*atp, atp+sin(fap*atp));
    
    float ofc = 17.;

    float ft = fract(cos(a*12.5*b));
    float fb = abs(cos(a*3.));
    float fbs = abs(sin(fb*a));
    float fbc = fb + fbs;
    float fab = abs(cos(a*3.));
    float fsb = abs(cos(a*ofc*sin(a)));
    float ftb = abs(cos(atp*ofc*sin(a)));
    fsb = ftb;
    float fpc =pow(fab, 2.0);
    // a = c;
    // f = fb + fbs;
    float f = cos(a*3.);
    f = fab;
    float fh = fpc +fsb;
    // fh = fpc +fsb*ft;
    fh = fab * qap + fh;
    f = fh;
    f -= abs(cos(a*2.5)*cos(b))*ft*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.+cos(time))*sin(time +a))*.8+.1;
    // f = (fbc)+smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

    float s =  1.-smoothstep(f,f+0.02,r);
    vec3 lake = vec3(s*fap, s*ft, b*s );
    // color += pct;
	  // color *= smoothstep(color.x + color.y, pct*color.z, color-pct*color.z);
    return lake;
  }
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float time;


// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
float time = u_time;
  
        mat2 rot2D(float angle) {
          float s = sin(angle);
          float c = cos(angle);
  
          return mat2(c, -s, s, c);
        }
        
		float rain() {  
          vec3 p = vec3(-90.5+sin(time*0.3));
          vec3 q = p;

          q = fract(p) - 0.5; // Space Repetition 0.5
            
 		  q.z = time * 0.4;
          return q.z; 
        }

		vec3 blueHaven(vec3 p, vec2 u) {
          vec2 pos = vec2(0.5)-u;
          p += vec3(-90.5+sin(time*0.3));
          // p += rot3D(p, q.xy, angle);  
  
          // Infinite city generation
          vec3 q = p; // input copy

          q = fract(p) - 0.5; // Space Repetition 0.5

          // Camera movement
          // q.xz *= rot2D(time *0.4);
          float rain = rain();
          q.z = time * 0.4; // Forward Camera Movement  
          q.y -= time * 0.4; // Upward Movement
      
          // pos *= rot2D(sin(q.z)); 
          // bottom-left
          vec2 bl = smoothstep(vec2(0.1),1.0-u, u);
          float pct = bl.x * bl.y;
      
          // top-right
          // vec2 tr = step(vec2(0.1),1.0-st);
          // pct *= tr.x * tr.y;
      
          vec3 basin = vec3(pct);        


      
          float ap = pos.x*sin(q.z*pct);
          float qap = tan(ap+sin(ap*q.z));
          float fap = (qap-q.z);
          float azp = pos.y*q.z;
          float asp = cos(sin(azp));
          float afp = atan(tan(asp*qap), q.z*azp*asp);
          float atp = pos.x*tan(q.z*sin(pct));
          float r = length(pos)*2.0;
          float a = atan(pos.y, atp);
          a = atan(azp, fap);
          a = atan((azp), afp);
          a = atan((azp*qap), cos(afp+fap));
          vec2 tp = vec2(a, qap);
          tp*= rot2D(sin(q.z / time)); 
            
          float b = atan(pos.y*tp.x, atp+sin(fap)*cos(tp.y));
          
          float ofc = 17.;
      
          float ft = fract(cos(a*12.5*b));
          float fb = abs(cos(a*3.));
          float fbs = abs(sin(3.*fb*a));
          p.xz *= rot2D(ft+time); 
          float fbc = fb + fbs;
          float fab = abs(cos(a*43.));
          float fsb = abs(cos(a*ofc*sin(a*3.)));
          float fpc =pow(fab, 2.0);
          // a = c;
          // f = fb + fbs;
          float f = cos(a*3.);
          f = fab-fbc;
          float fh = fpc +fsb;
          fh = fab * qap + fh;
          f = fh;
          // f = abs(cos(a*2.5)*cos(b))*ft*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.+cos(time))*sin(time +a))*.8+.1;
          // f = (fbc)+smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
      
      
          float shape =  1.-smoothstep(f,f+0.02,r);
          vec3 haven = vec3(shape*fap, shape*ft, basin*shape );
          // basin *= pct;
          // basin *= smoothstep(basin.x + basin.y, pct*basin.z, basin-pct*basin.z);
          return haven+basin; 
          // basin += pct;
          // basin *= smoothstep(basin.x + basin.y, pct*basin.z, basin-pct*basin.z);
          return haven;
        }

void main(){
    vec2 uv = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    vec2 pos = vec2(0.5)-uv;

    float r = length(pos)*2.0;
    float a = atan(pos.y,pos.x);

    float f = cos(a*3.);
    // f = abs(cos(a*3.));
    // f = abs(cos(a*2.5))*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

    color = vec3( 1.-smoothstep(f,f+0.02,r) );
    color = blueHaven(vec3(uv, pos.y), uv);
    // color = blueHaven(vec3(uv, pos.y), uv);

    gl_FragColor = vec4(color, 1.0);
}



vec3 interpolate(vec3 a, vec3 b, float t) {
  return mix(a, b, t); // built-in linear interpolation
  // or equivalently:
  // return a + (b - a) * t;
}

float S(float t) {
  return t * t * (3.0 - 2.0 * t); // smootherstep or easeInOut
}

vec3 smoothLerp(vec3 a, vec3 b, float t) {
  return mix(a, b, S(t));
}

float powerDrop(float t) {
  return pow(t, 3.0); // fast drop (ease-in cubic)
}

vec3 waterfall(vec3 a, vec3 b, float t) {
  return mix(a, b, powerDrop(t));
}

float hill(float t) {
  return sin(t * 3.14159); // classic hill shape: sin(pi * t)
}


// ðŸ§  NEW: Fractal hill height
// float fractalHill(float t) {
//   float total = 0.0;
//   float amplitude = 1.0;
//   float frequency = 1.0;
//   float persistence = 0.5;

//   for (int i = 0; i < 4; i++) {
//     total += sin(t * frequency * 3.14159) * amplitude;
//     amplitude *= persistence;
//     frequency *= 2.0;
//   }

//   return total * 0.5 + 0.5; // normalize
// }


#ifdef GL_ES
precision mediump float;
#endif

uniform float iTime;
uniform vec2 iResolution;


// Main
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;

  // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);

  // March
  float dist = raymarch(ro, rd);
  vec3 p = ro + rd * dist;

  // Shading
  vec3 col = vec3(0.6, 0.85, 0.4); // default grass color
  if (dist < MAX_DIST) {
    vec3 normal = estimateNormal(p);
    float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
    col = vec3(0.3, 0.6, 0.2) * diff;
  } else {
    col = vec3(0.6, 0.8, 1.0); // sky
  }

  fragColor = vec4(col, 1.0);
}




////////////////////
// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com






/////////Bright Land Scape//////// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
vec3 dgv;

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001

// === Fractal Hill Pattern ===
float fractalHill(float t) {
  float total = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  float persistence = 0.5;

  for (int i = 0; i < 4; i++) {
    total += sin(t * frequency * 3.14159) * amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return total * 0.5 + 0.5; // normalize to [0,1]
}

// Terrain height using XZ
float terrainHeight(vec2 posXZ) {
  return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
}

// Usage
float getHeight(float t) {
  return fractalHill(t); // fractal height
}

float ripple(float t) {
  return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
}

float hillTerrain(float t) {
  return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
}

vec3 path (vec3 startPos, vec3 endPos, float t){
  return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
}

float linearTerrainSDF(vec3 p) {
  // simulate terrain along X
  float h = fractalHill(p.x);
  return p.y - h; // above = positive, below = negative
}

// 3D terrain SDF
float terrainSDF(vec3 p) {
  float h = terrainHeight(p.xz);
  return p.y - h;
}

float terrainVolumeSDF(vec3 p) {
  float h = terrainHeight(p.xz); // 2D hill over XZ
  return p.y - h;
}


// Estimate normal from SDF
vec3 computeNormal(vec3 p) {
  float d = terrainVolumeSDF(p);
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    terrainVolumeSDF(p + e.xyy) - d,
    terrainVolumeSDF(p + e.yxy) - d,
    terrainVolumeSDF(p + e.yyx) - d
  ));
}

vec3 terrainColor(vec3 p, float d) {
  // Shading
  vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;
  } else {
    color = vec3(0.6, 0.8, 1.0); // sky
  }
    return color;
}

// Raymarching algorithm
float renderer(vec3 ro, vec3 rd) {
  float t = 0.0;
  for (int i = 0; i < MAX_STEPS; i++) {
    vec3 p = ro + rd * t;
    float d = terrainVolumeSDF(p);
    if (d < SURF_DIST || t > MAX_DIST) break;
    t += d;
  }
  return t;
}

float rayPower( vec3 p, float d, float t) {
  float depthFactor = 0.064;
  float ray = t * 0.2 * depthFactor;

  // ðŸŒ¿ Base shading â€” default grass tint
  dgv *= vec3(0.6, 0.85, 0.4);

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    vec3 terrainColor = vec3(0.3, 0.6, 0.2);
    dgv *= terrainColor * diff;

    // âœ… (Optional) Drop shadows back in when ready:
    // float shadow = computeSoftShadow(p + normal * 0.05, lightPos);
    // color *= shadow;
  } else {
    dgv *= vec3(0.6, 0.8, 1.0); // sky tint
  }
  return ray;
}

vec2 raymarch(vec3 ro, vec3 rd) {
  float t = 0.0; // Total Distance Travelled By Ray
  vec3 dgv = vec3(t);
  vec3 p; // declared outside loop so it's accessible after
  float d = 0.0;

  for (int i = 0; i < 80; i++) {
    p = ro + rd * t;
    d = terrainVolumeSDF(p);
    if (d < 0.001 || t > 100.0) break;

    t += d;
    dgv = vec3(i) / 80.0;
  }
  float ray = rayPower(p, d, t);

  return vec2(t, ray);
}

void main(){
    vec2 uv = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    vec2 pos = vec2(0.5)-uv;

    float r = length(pos)*2.0;
    float a = atan(pos.y,pos.x);

    float f = cos(a*3.);
    // f = abs(cos(a*3.));
    // f = abs(cos(a*2.5))*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
    
  // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);

  // March
  vec2 renderer = raymarch(ro, rd);
  float d = renderer.x;
  float ray = renderer.y;
  vec3 p = ro + rd * d;
  vec3 terrain = terrainColor(p, d);


    color = vec3( 1.-smoothstep(f,f+0.02,r) );
    color = terrain*r;

    gl_FragColor = vec4(color, 1.0);
}









#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001

// === Fractal Hill Pattern ===
float fractalHill(float t) {
  float total = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  float persistence = 0.5;

  for (int i = 0; i < 4; i++) {
    total += sin(t * frequency * 3.14159) * amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return total * 0.5 + 0.5; // normalize to [0,1]
}
mat2 rot2D(float angle) {
  float s = sin(angle);
  float c = cos(angle);
  return mat2(c, -s, s, c);
}

// Terrain height using XZ
float terrainHeight(vec2 posXZ) {
  return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
}

// Usage
float getHeight(float t) {
  return fractalHill(t); // fractal height
}

float ripple(float t) {
  return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
}

float hillTerrain(float t) {
  return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
}

vec3 path (vec3 startPos, vec3 endPos, float t){
  return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
}

float linearTerrainSDF(vec3 p) {
  // simulate terrain along X
  float h = fractalHill(p.x+u_time);
  return p.y - h; // above = positive, below = negative
}

// 3D terrain SDF
float terrainSDF(vec3 p) {
  float h = terrainHeight(p.xz);
  return p.y - h;
}

float terrainVolumeSDF(vec3 p) {
  float h = terrainHeight(p.xz); // 2D hill over XZ
  return p.y - h;
}


// Estimate normal from SDF
vec3 computeNormal(vec3 p) {
  float d = terrainVolumeSDF(p);
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    terrainVolumeSDF(p + e.xyy) - d,
    terrainVolumeSDF(p + e.yxy) - d,
    terrainVolumeSDF(p + e.yyx) - d
  ));
}

// Raymarching algorithm
float renderer(vec3 ro, vec3 rd) {
  float t = 0.0;
  for (int i = 0; i < MAX_STEPS; i++) {
    vec3 p = ro + rd * t;
    float d = terrainVolumeSDF(p) + linearTerrainSDF(p);
    if (d < SURF_DIST || t > MAX_DIST) break;
    t += d;
  }
  return t;
}

vec4 raymarch(vec3 ro, vec3 rd) {
  float depthFactor = 0.064;
  float t = 0.0; // Total Distance Travelled By Ray
  vec3 depthGreyValue = vec3(t);
  vec3 p; // declared outside loop so it's accessible after
  float d = 0.0;

  for (int i = 0; i < 80; i++) {
    p = ro + rd * t;
    d = terrainVolumeSDF(p) + linearTerrainSDF(p);
    if (d < 0.001 || t > 100.0) break;

    t += d;
    depthGreyValue = vec3(i) / 80.0;
  }

  float rayPower = t * 0.2 * depthFactor;

  // ðŸŒ¿ Base shading â€” default grass tint
  vec3 color = depthGreyValue * vec3(0.6, 0.85, 0.4);

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    vec3 terrainColor = vec3(0.3, 0.6, 0.2);
    color = depthGreyValue * terrainColor * diff;

    // âœ… (Optional) Drop shadows back in when ready:
    // float shadow = computeSoftShadow(p + normal * 0.05, lightPos);
    // color *= shadow;
  } else {
    color = depthGreyValue * vec3(0.6, 0.8, 1.0); // sky tint
  }

  return vec4(color, rayPower);
}

vec3 terrainColor(vec3 p, float d) {
  // Shading
  vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;
  } else {
    color = vec3(0.6, 0.8, 1.0); // sky
  }
    return color;
}


void main(){
    vec2 uv = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    vec2 pos = vec2(0.5)-uv;

    float r = length(pos)*2.0;
    float a = atan(pos.y,pos.x);

    float f = cos(a*3.);
    // f = abs(cos(a*3.));
    // f = abs(cos(a*2.5))*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
    
  // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);

  // March
  vec4 march = raymarch(ro, rd);
  float d = renderer(ro, rd);
  vec3 p = ro + rd * d;
  vec3 terrain = terrainColor(p, d);

  // Shading
//   vec3 col = vec3(0.6, 0.85, 0.4); // default grass color
//   if (dist < MAX_DIST) {
//     vec3 normal = computeNormal(p);
//     float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
//     col = vec3(0.3, 0.6, 0.2) * diff;
//   } else {
//     col = vec3(0.6, 0.8, 1.0); // sky
//   }


    color = vec3( 1.-smoothstep(f,f+0.02,r) );
    color = march.rgb/terrain/r;

    gl_FragColor = vec4(color, 1.0);
}








#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001

// === Fractal Hill Pattern ===
float fractalHill(float t) {
  float total = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  float persistence = 0.5;

  for (int i = 0; i < 4; i++) {
    total += sin(t * frequency * 3.14159) * amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return total * 0.5 + 0.5; // normalize to [0,1]
}
mat2 rot2D(float angle) {
  float s = sin(angle);
  float c = cos(angle);
  return mat2(c, -s, s, c);
}

// Terrain height using XZ
float terrainHeight(vec2 posXZ) {
  return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
}

// Usage
float getHeight(float t) {
  return fractalHill(t); // fractal height
}

float ripple(float t) {
  return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
}

float hillTerrain(float t) {
  return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
}

vec3 path (vec3 startPos, vec3 endPos, float t){
  return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
}

float linearTerrainSDF(vec3 p) {
  // simulate terrain along X
  float h = fractalHill(p.x+u_time);
  return p.y - h; // above = positive, below = negative
}

// 3D terrain SDF
float terrainSDF(vec3 p) {
  float h = terrainHeight(p.xz);
  return p.y - h;
}

float terrainVolumeSDF(vec3 p) {
  float h = terrainHeight(p.xz); // 2D hill over XZ
  return p.y - h;
}


// Estimate normal from SDF
vec3 computeNormal(vec3 p) {
  float d = terrainVolumeSDF(p);
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    terrainVolumeSDF(p + e.xyy) - d,
    terrainVolumeSDF(p + e.yxy) - d,
    terrainVolumeSDF(p + e.yyx) - d
  ));
}

// Raymarching algorithm
float renderer(vec3 ro, vec3 rd) {
  float t = 0.0;
  for (int i = 0; i < MAX_STEPS; i++) {
    vec3 p = ro + rd * t;
    float d = terrainVolumeSDF(p) + linearTerrainSDF(p);
    if (d < SURF_DIST || t > MAX_DIST) break;
    t += d;
  }
  return t;
}

vec4 raymarch(vec3 ro, vec3 rd) {
  float depthFactor = 0.064;
  float t = 0.0; // Total Distance Travelled By Ray
  vec3 depthGreyValue = vec3(t);
  vec3 p; // declared outside loop so it's accessible after
  float d = 0.0;

  for (int i = 0; i < 80; i++) {
    p = ro + rd * t;
    d = terrainVolumeSDF(p) + linearTerrainSDF(p);
    if (d < 0.001 || t > 100.0) break;

    t += d;
    depthGreyValue = vec3(i) / 80.0;
  }

  float rayPower = t * 0.2 * depthFactor;

  // ðŸŒ¿ Base shading â€” default grass tint
  vec3 color = depthGreyValue * vec3(0.6, 0.85, 0.4);

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    vec3 terrainColor = vec3(0.3, 0.6, 0.2);
    color = depthGreyValue * terrainColor * diff;

    // âœ… (Optional) Drop shadows back in when ready:
    // float shadow = computeSoftShadow(p + normal * 0.05, lightPos);
    // color *= shadow;
  } else {
    color = depthGreyValue * vec3(0.6, 0.8, 1.0); // sky tint
  }

  return vec4(color, rayPower);
}

vec3 terrainColor(vec3 p, float d) {
  // Shading
  vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;
  } else {
    color = vec3(0.6, 0.8, 1.0); // sky
  }
    return color;
}


void main(){
    vec2 uv = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    vec2 pos = vec2(0.5)-uv;

    float r = length(pos)*2.0;
    float a = atan(pos.y,pos.x);

    float f = cos(a*3.);
    // f = abs(cos(a*3.));
    // f = abs(cos(a*2.5))*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
    
  // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);

  // March
  vec4 march = raymarch(ro, rd);
  float d = renderer(ro, rd+u_time);
  vec3 p = ro + rd * d;
  vec3 terrain = terrainColor(p, d);

  // Shading
//   vec3 col = vec3(0.6, 0.85, 0.4); // default grass color
//   if (dist < MAX_DIST) {
//     vec3 normal = computeNormal(p);
//     float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
//     col = vec3(0.3, 0.6, 0.2) * diff;
//   } else {
//     col = vec3(0.6, 0.8, 1.0); // sky
//   }


    color = vec3( 1.-smoothstep(f,f+0.02,r) );
    color = march.rgb/r;

    gl_FragColor = vec4(color, 1.0);
}











// vec3 rayPower( vec3 p, float d, float t) {
//   float depthFactor = 0.064;
//   float ray = t * 0.2 * depthFactor;

//   // ðŸŒ¿ Base shading â€” default grass tint
//   vec3 depthColor = vec3(0.6, 0.85, 0.4);

//   if (d < MAX_DIST) {
//     vec3 normal = computeNormal(p);
//     float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
//     vec3 terrainColor = vec3(0.3, 0.6, 0.2);
//     depthColor *= terrainColor * diff;

//     // âœ… (Optional) Drop shadows back in when ready:
//     // float shadow = computeSoftShadow(p + normal * 0.05, lightPos);
//     // depthColor *= shadow;
//   } else {
//     depthColor *= vec3(0.6, 0.8, 1.0); // sky tint
//   }
//   return depthColor*ray;
// }


float getElevation(vec2 xz) {
    return sin(xz.x * 0.3) * cos(xz.y * 0.2); // Cheap terrain
}

vec2 boundary(vec2 u) {
    return vec2(min(u.x, 1.0 - u.x), min(u.y, 1.0 - u.y));
}

vec4 borders(vec2 u) {
    return vec4(
        u.x,             // distance from left
        1.0 - u.x,       // distance from right
        u.y,             // distance from bottom
        1.0 - u.y        // distance from top
    );
}
vec4 deviceDepthPixelDimension(vec2 u) {
    vec2 p = vec2(0.5) - u;

    float r = length(p) * 2.0;
    float a = atan(p.y, p.x);
    float f = cos(a * 3.0);

    vec2 wall = borders(uv);  // NEW: How close to left/right or top/bottom
    float depth = min(wall.x, wall.y);  // use closest edge

    return vec4(r, a, f, depth);  // now you have screen-depth too!
}

vec5 elevatedDeviceDepthPixelDimension(vec2 u) {
    vec2 p = vec2(0.5) - u;

    float r = length(p) * 2.0;
    float a = atan(p.y, p.x);
    float f = cos(a * 3.0);

    vec4 wall = borders(u);
    float depth = min(wall.x, wall.y);

    float elevation = getElevation(u * 10.0); // Scaled terrain detail

    return vec5(r, a, f, depth, elevation);
}
vec4 d = deviceDepthPixelDimension(uv);
float r = d.x;
float a = d.y;
float f = d.z;
float edgeFalloff = d.w;

float elevation = getElevationAt(uv);

vec3 col = vec3(0.0);
col.r = f * 0.6 + elevation;
col.g = sin(r * 2.0 + elevation * 2.0);
col.b = edgeFalloff;

gl_FragColor = vec4(col, 1.0);


















#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
uniform float climateCondition;
uniform float hovered;
vec2 mouse = u_mouse;

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001

// === Fractal Hill Pattern ===
float fractalHill(float t) {
  float total = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  float persistence = 0.5;

  for (int i = 0; i < 4; i++) {
    total += sin(t * frequency * 3.14159) * amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return total * 0.5 + 0.5; // normalize to [0,1]
}

// Terrain height using XZ
float terrainHeight(vec2 posXZ) {
  return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
}

// Usage
float getHeight(float t) {
  return fractalHill(t); // fractal height
}

float addRipples(float t) {
  return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
}

float hillTerrain(float t) {
  return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
}

vec3 getPath (vec3 startPos, vec3 endPos, float t){
  return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
}

float linearTerrainSDF(vec3 p) {
  // simulate terrain along X
  float h = fractalHill(p.x);
  return p.y - h; // above = positive, below = negative
}

// 3D terrain SDF
float terrainSDF(vec3 p) {
  float h = terrainHeight(p.xz);
  return p.y - h;
}

float terrainVolumeSDF(vec3 p) {
  float h = terrainHeight(p.xz); // 2D hill over XZ
  return p.y - h;
}

// Estimate normal from SDF
vec3 computeNormal(vec3 p) {
  float d = terrainVolumeSDF(p);
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    terrainVolumeSDF(p + e.xyy) - d,
    terrainVolumeSDF(p + e.yxy) - d,
    terrainVolumeSDF(p + e.yyx) - d
  ));
}

vec3 terrainColor(vec3 p, float d) {
  // Shading
  vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;
  } else {
    color = vec3(0.6, 0.8, 1.0); // sky
  }
    return color;
}

float getLandScape(vec3 p, vec3 path) {
  float landScape = terrainVolumeSDF(p)* linearTerrainSDF(p+path);// LandScape;
    // landScape = terrainVolumeSDF(p)* linearTerrainSDF(p+path)+hillTerrain(p.y); // landForest
    // landScape = terrainVolumeSDF(p)* linearTerrainSDF(p+path)+hillTerrain(p.z); //Grassland
    // landScape = (terrainVolumeSDF(p)* linearTerrainSDF(p+path)+hillTerrain(p.z)); //Grassland
  return landScape;	  
}

vec3 tropicalSeasons(vec3 p, vec3 depthGreyValue, float ray, float t){
   float ripples = addRipples(ray*sin(u_time+0.7));
  // ðŸŒ¿ Base shading â€” default grass tint
  vec3 color = depthGreyValue * vec3(0.6, 0.85, 0.4);
   vec3 landScape = terrainColor(p, t);
    color = depthGreyValue * landScape;
   vec3 cloudyLandScape = terrainColor(p, t*ripples); //Cloud Rain Lightning
   vec3 foggyLandScape = terrainColor(p, t/ripples);// Forest floods

    vec3 field = depthGreyValue * landScape;
    // field = depthGreyValue * cloudyLandScape;//RainForest
    // field = depthGreyValue * foggyLandScape; // FloodedDelta
    // field = depthGreyValue * foggyLandScape; // Bad Weather dark bout to rain heavy
   return field;
}
vec3 tropicalWeatherConditions(vec3 p, vec3 depthGreyValue, float ray, float t){
    float ripples = addRipples(ray * sin(u_time + 0.7));
    
    // Base terrain colors
    vec3 landScape       = terrainColor(p, t);
    vec3 cloudyLandScape = terrainColor(p, t * ripples);     // Cloudy/Rain
    vec3 foggyLandScape  = terrainColor(p, t / ripples);     // Fog/Flood

    vec3 field;

    if (climateCondition == .0) {
        // â˜€ï¸ Clear
        field = depthGreyValue * landScape;
    } else if (climateCondition == 1.0) {
        // ðŸŒ§ï¸ Rain
        field = mix(depthGreyValue * landScape, depthGreyValue * cloudyLandScape, 0.6);
    } else if (climateCondition == 2.0) {
        // ðŸŒŠ Flood
        field = mix(depthGreyValue * foggyLandScape, vec3(0.0, 0.2, 0.3), 0.7);
    } else if (climateCondition == 3.0) {
        // â›ˆï¸ Storm â€” darker, more intense variation
        vec3 darkStorm = mix(foggyLandScape, cloudyLandScape, 0.5);
        field = depthGreyValue * darkStorm * 0.5;
    } else {
        // Default fallback
        field = depthGreyValue * landScape;
    }

    return field;
}

// Raymarching algorithm
float renderer(vec3 ro, vec3 rd) {
  float t = 0.0;
  for (int i = 0; i < MAX_STEPS; i++) {
    vec3 p = ro + rd * t;
    float d = terrainVolumeSDF(p) + linearTerrainSDF(p);
    if (d < SURF_DIST || t > MAX_DIST) break;
    t += d;
  }
  return t;
}

vec4 raymarch(vec3 ro, vec3 rd) {
  float depthFactor = 0.064;
  float t = 0.0; // Total Distance Travelled By Ray
  vec3 depthGreyValue = vec3(t);
  vec3 p; // declared outside loop so it's accessible after
  float d = 0.0;
  vec3 path = getPath(ro, rd, t) ;

  for (int i = 0; i < 80; i++) {
    p = ro + rd * t;
    float d = getLandScape(p, path);
    if (d < 0.001 || t > 100.0) break;

    t += d;
    depthGreyValue = vec3(i) / 80.0;
  }

  float ray = t * 0.2 * depthFactor;
   float rpl = addRipples(ray*sin(u_time+0.7));
    
    // vec3 rayColor= rayPower(p, d, t);
    vec3 color = tropicalSeasons(p, depthGreyValue, ray, t);

  return vec4(color, ray);
}

float sdSun(vec2 u) {
  vec2 p = vec2(0.5)-u;
  return length(p)*2.0;
}

vec3 sunLight(vec2 uv) {
    float d = sdSun(uv);  // you can vary this radius
    float mask = 1.0 - smoothstep(0.0, 0.02, d);
    vec3 color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 0.9, 1.0), sin(u_time * 0.25) * 0.5 + 0.5);
    return color * mask;
}

float getElevation(vec2 xz) {
    return sin(xz.x * 0.3) * cos(xz.y * 0.2); // Cheap terrain
}

vec2 boundary(vec2 u) {
    return vec2(min(u.x, 1.0 - u.x), min(u.y, 1.0 - u.y));
}

vec4 borders(vec2 u) {
    return vec4(
        u.x,             // distance from left
        1.0 - u.x,       // distance from right
        u.y,             // distance from bottom
        1.0 - u.y        // distance from top
    );
}



vec4 deviceDepthPixelDimension(vec2 u) {
    vec2 p = vec2(0.5) - u;

    float r = length(p) * 2.0;
    float a = atan(p.y, p.x);
    float f = cos(a * 3.0);

    vec4 wall = borders(u);  // NEW: How close to left/right or top/bottom
    float depth = min(wall.x, wall.y);  // use closest edge

    return vec4(r, a, f, depth);  // now you have screen-depth too!
}




struct DeviceInfo {
    float r;
    float a;
    float f;
    float depth;
    float elevation;
};

DeviceInfo getDeviceInfo(vec2 u) {
    vec2 p = vec2(0.5) - u;

    DeviceInfo info;
    info.r = length(p) * 2.0;
    info.a = atan(p.y, p.x);
    info.f = cos(info.a * 3.0);

    vec4 wall = borders(u);
    info.depth = min(wall.x, wall.y);
    info.elevation = getElevation(u * 10.0);

    return info;
}

vec3 dimensions(vec2 u) {
    vec2 p = vec2(0.5)-u;
vec4 d = deviceDepthPixelDimension(u);
// float r = d.x;
float a = d.y;
float f = d.z;
float e = d.w;

float elevation = getElevation(u);

vec3 col = vec3(0.0);
col.r = f * 0.6 + elevation;
// col.g = sin(r * 2.0 + elevation * 2.0);
col.b = e;

    float r = length(p)*2.0;  // This can serve as the Sun since sdf circle need only r
    // float a = atan(p.y,p.x);

    // float f = cos(a*3.);
    f = abs(cos(a*3.*f*e*tan(f * 0.6 + elevation)))-r;
    // f = abs(cos(a*2.5))*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
    return vec3(r, a, f);
}
vec2 computeHeightDimensions(vec2 uv) {
    vec3 dims = dimensions(uv);
    float r = dims.x;
    float a = dims.y;

    float h = r * sin(a*u_time);
    float w = r * cos(a*u_time);

    return vec2(h, w); // vertical and horizontal projection
}

void main(){
    vec2 uv = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    vec2 pos = vec2(0.5)-uv;
    vec3 specs = dimensions(uv);
    float r = specs.x;
    float a = specs.y;
    float f = specs.z;
    float sun = sdSun(uv);
    
  // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);

  // March
  vec4 render = raymarch(ro, rd);
  // float d = renderer(ro, rd+u_time);
  // float dist = march.w;
  // vec3 p = ro + rd * dist;


    // color = vec3( 1.-smoothstep(f,f+0.02,r) );
    // color *= d;
    color = render.rgb/sun;
    // color += sunLight(uv)+r; float bug = metalBug(uvt, uv);

          // Check if hovered is active or not
          float absT =  abs(sin(u_time));
          if (hovered > 0.0) {
            // Mouse is hovering, apply mouse interaction effects
            float dist = distance(mouse, uv);
            // dist +=  absT;


            // Use the distance to influence the color (make mouse position cause a color shift)
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Makes the area closer to the mouse lighter (for visible effect)

            // Use distance to control the opacity
            float opacity = smoothstep(0.0, 0.5, dist); // Opacity decreases with distance from the mouse position
            // opacity *= bug;

//             color = mix(vec3(bug), color, bug * u_time);
  
            // Optionally, add u_time-based animation for extra dynamics
            color *= 0.5 + 0. * sin(u_time + dist * 10.0); // Add a dynamic oscillating effect based on distance and u_time

            gl_FragColor = vec4(color, opacity);
          } else {
            // Mouse is not hovering, apply default effect based on UV coordinates and distance
            float dist = distance(uv, vec2(0.5, 0.5)); // Default base distance, could be replaced with your original calculation
            // color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Use original UV-distance-based coloring
            color *= 0.5 + 0.5 * sin(u_time + dist * 10.0); // Add a dynamic oscillating effect based on distance and u_time
    	color += render.rgb/sun;
             // color *= col;
             // color = vec3(shape, shape, 0.0);

        float opacity = smoothstep(0.6, 0.8, 1.0);
            gl_FragColor = vec4(color, opacity); // Default behavior
          }

}


float speed = length(u_meshVelocity);
vec3 glow = vec3(speed) * 0.3;

float dist = length(gl_FragCoord.xy / u_resolution.xy - u_entityPosition.xy);
float rippleEffect = sin(dist * 20.0 - u_rippleTime * 3.0) * exp(-dist * 10.0);

/** Want a helper utility to abstract shader input updates per object? 
  Or want to animate a ripple ring from each collision? 
*/