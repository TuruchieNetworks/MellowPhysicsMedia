
//// Blue Curtain
#ifdef GL_ES
precision mediump float;
#endif


#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001
vec3 dgv;

float hash21(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 78.233);
    return fract(p.x * p.y);
}
// === Fractal Hill Pattern ===
float fractalHill(float t) {
  float total = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  float persistence = 0.5;

  for (int i = 0; i < 4; i++) {
    total += sin(t * frequency * 3.14159) * amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return total * 0.5 + 0.5; // normalize to [0,1]
}

// Terrain height using XZ
float terrainHeight(vec2 posXZ) {
  return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
}

// Usage
float getHeight(float t) {
  return fractalHill(t); // fractal height
}

float sdBox( vec3 p, vec3 b ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float ripple(float t) {
  return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
}

float hillTerrain(float t) {
  return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
}

vec3 path (vec3 startPos, vec3 endPos, float t){
  return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
}

float linearTerrainSDF(vec3 p) {
  // simulate terrain along X
  float h = fractalHill(p.x);
  return p.y - h; // above = positive, below = negative
}

// 3D terrain SDF
float terrainSDF(vec3 p) {
  float h = terrainHeight(p.xz);
  return p.y - h;
}

float terrainVolumeSDF(vec3 p) {
  float h = terrainHeight(p.xz); // 2D hill over XZ
  return p.y - h;
}

float sdCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float treeSDF(vec3 p) {
    // Distribute trees periodically over terrain
    vec2 cell = floor(p.xz * 2.0); // spacing
    vec3 localP = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
    localP.y -= terrainHeight(cell + 0.5); // offset by terrain

    float trunk = sdCylinder(localP,  0.5, 0.05); // trunk
    return trunk;
}

float foliageSDF(vec3 p, vec3 base, float rnd) {
    float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
    vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
    // vec3 q = fract(p)-0.5;
    return length(p - canopyCenter) - 0.15; // sphere canopy
}

float sceneSDF(vec3 p) {
    vec3 q = fract(p);
    float terrain = terrainVolumeSDF(p);
    float tree = treeSDF(p);
    float foliage = min(foliageSDF(q, (log(q)), tree), tree);
    return min(min(terrain, tree), foliage);
}

// Estimate normal from SDF
vec3 computeNormal(vec3 p) {
  float d = terrainVolumeSDF(p);
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    terrainVolumeSDF(p + e.xyy) - d,
    terrainVolumeSDF(p + e.yxy) - d,
    terrainVolumeSDF(p + e.yyx) - d
  ));
}

vec3 terrainColor(vec3 p, float d) {
  vec3 color;

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;

    if (treeSDF(p) < 0.02) {
      color = vec3(0.25, 0.1, 0.05); // trunk
    }

    if (foliageSDF(p, vec3(0.0), hash21(p.xz)) < 0.03) {
      color = vec3(0.1, 0.4, 0.1); // canopy
    }

  } else {
    color = vec3(0.6, 0.8, 1.0); // sky

  }

  return color;
}

float rayPower(vec3 p, float d, float t) {
  float depthFactor = 0.064;
  float ray = t * 0.2 * depthFactor;
  vec3 color;

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;

    float treeDist = treeSDF(p);
    if (treeDist < 0.02) {
      color = vec3(0.25, 0.1, 0.05);
    }

    float canopy = foliageSDF(p, vec3(0.0),   hash21(p.xz));
    if (canopy < 0.03) {
      color = vec3(0.1, 0.4, 0.1);
    }

  } else {
    color = vec3(0.6, 0.8, 1.0); // base sky tint
  }

  return ray;
}

vec2 raymarch(vec3 ro, vec3 rd) {
  float t = 0.0; // Total Distance Travelled By Ray
  dgv = vec3(t);
  vec3 p; // declared outside loop so it's accessible after
  float d = 0.0;

  for (int i = 0; i < 80; i++) {
    p = ro + rd * t;
    d = min(terrainVolumeSDF(p), sceneSDF(p));
      d = sceneSDF(p);
    if (d < 0.001 || t > 100.0) break;

    t += d;
    dgv = vec3(i) / 80.0;
  }
  float ray = rayPower(p, d, t);
  dgv = terrainColor(p, d);
  return vec2(t, ray);
}

vec4 borders(vec2 u) {
    return vec4(
        u.x,             // distance from left
        1.0 - u.x,       // distance from right
        u.y,             // distance from bottom
        1.0 - u.y        // distance from top
    );
}

vec4 deviceDepthPixelDimension(vec2 u) {
    vec2 p = vec2(0.5) - u;

    float r = length(p) * 2.0;
    float a = atan((p.y), sin(p.x))*sin(.3*r);
    float f = cos(a*3.0+time);

    // f = abs(cos(a*3.));
    // f = abs(cos(a*2.5))*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
    // float shape = 1.-smoothstep(f,f+0.02,r);

    vec4 wall = borders(u);  // NEW: How close to left/right or top/bottom
    float depth = min(wall.x, wall.y);  // use closest edge

    return vec4(r, a, f, depth);  // now you have screen-depth too!
}

float computeGlowFactor(float s) {
	return s * 0.1;
}


void main(){
  vec2 u = gl_FragCoord.xy/resolution.xy;

  float glow = computeGlowFactor(4.67);
  vec4 device = deviceDepthPixelDimension(u);
  float d = device.w;
  float r = device.x;
  float a = device.y;
  float f = device.z;

    // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(u.x * right + u.y * up + 1.5 * forward);

  // March
  vec2 renderer = raymarch(ro, rd);
  float t = renderer.x;
  float ray = renderer.y;
  vec3 p = ro*a + rd * t+(time*0.1);
  vec3 terrain = terrainColor(p, t);

    color = vec3(terrain.x/a, (terrain.y*terrain.x-r), terrain.z+r/time)/r*(glow) + dgv*ray;

    gl_FragColor = vec4(color, 1.0);
}

// moveToward(vec3 a, vec3 b, vec3 speed, float dt) {
//   v = b-a;
//   stepDist = speed*dt;
//   if(stepDist >=abs(v)) {
//     return b; // prevents overshooot
//   }
//   else{
//     return a+ sign(v)*stepDist
//   }
// }
vec3 moveToward(vec3 a, vec3 b, float speed, float dt) {
    vec3 dir = b - a;
    float dist = length(dir);
    float step = speed * dt;

    if (step >= dist) {
        return b; // Prevent overshoot
    }

    return a + normalize(dir) * step;
}

vec3 lerp(vec3 a, vec3 b, float t) {
    return a + (b - a) * t;
}





uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
float time = u_time;
vec2 resolution = u_resolution.xy; 

void main(){
    vec2 uv = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    vec2 pos = vec2(0.5)-uv;





// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
vec2 resolution = u_resolution.xy;
float time = u_time;
// Blue Skies

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001
vec3 dgv;

// === Fractal Hill Pattern ===
float fractalHill(float t) {
  float total = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  float persistence = 0.5;

  for (int i = 0; i < 4; i++) {
    total += sin(t * frequency * 3.14159) * amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return total * 0.5 + 0.5; // normalize to [0,1]
}

// Terrain height using XZ
float terrainHeight(vec2 posXZ) {
  return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
}

// Usage
float getHeight(float t) {
  return fractalHill(t); // fractal height
}

float hash21(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 78.233);
    return fract(p.x * p.y);
}

float ripple(float t) {
  return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
}

float hillTerrain(float t) {
  return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
}

vec3 path (vec3 startPos, vec3 endPos, float t){
  return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
}

float linearTerrainSDF(vec3 p) {
  // simulate terrain along X
  float h = fractalHill(p.x);
  return p.y - h; // above = positive, below = negative
}

// 3D terrain SDF
float terrainSDF(vec3 p) {
  float h = terrainHeight(p.xz);
  return p.y - h;
}

float terrainVolumeSDF(vec3 p) {
  float h = fract(terrainHeight(p.xz)); 
  return p.y - h;
}

float sdCylinder(vec3 p, float h, float r) {
    vec3 q = fract(p);
    float lt = linearTerrainSDF(p);
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float treeSDF(vec3 p) {
    // Distribute trees periodically over terrain
    vec2 cell = floor(p.xz * 2.0); // spacing
    vec3 localP = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
    localP.y -= terrainHeight(cell + 0.5); // offset by terrain

    float trunk = sdCylinder(localP,  0.5, 0.05); // trunk
    return trunk;
}

float foliageSDF(vec3 p, vec3 base, float rnd) {
    float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
    vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
    return length(p - canopyCenter) - 0.15; // sphere canopy
}

float sceneSDF(vec3 p) {
    vec3 q = fract(p);
    float terrain = terrainVolumeSDF(p);
    float tree = treeSDF(p);
    float foliage = min(foliageSDF(q, (log(q)), tree), tree);
    return min(min(terrain, tree), foliage);
}

// Estimate normal from SDF
vec3 computeNormal(vec3 p) {
  float d = terrainVolumeSDF(p);
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    terrainVolumeSDF(p + e.xyy) - d,
    terrainVolumeSDF(p + e.yxy) - d,
    terrainVolumeSDF(p + e.yyx) - d
  ));
}

vec3 terrainColor(vec3 p, float d) {
  // Shading
  vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;
  } else {
    color = vec3(0.6, 0.8, 1.0); // sky
  }
    return color;
}

float rayPower(vec3 p, float d, float t) {
  float depthFactor = 0.064;
  float ray = t * 0.2 * depthFactor;
  vec3 color;

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;

    float treeDist = treeSDF(p);
    if (treeDist < 0.02) {
      color = vec3(0.25, 0.1, 0.05);
    }

    float canopy = foliageSDF(p, vec3(0.0), hash21(p.xz));
    if (canopy < 0.03) {
      color = vec3(0.1, 0.4, 0.1);
    }

  } else {
    color = vec3(0.6, 0.8, 1.0); // base sky tint
  }

  return ray;
}

vec2 raymarch(vec3 ro, vec3 rd) {
  float t = 0.0; // Total Distance Travelled By Ray
  dgv = vec3(t);
  vec3 p; // declared outside loop so it's accessible after
  float d = 0.0;

  for (int i = 0; i < 80; i++) {
    p = ro + rd * t;
    d = min(terrainVolumeSDF(p), sceneSDF(p));
    if (d < 0.001 || t > 100.0) break;

    t += d;
    dgv = vec3(i) / 80.0;
  }
  float ray = rayPower(p, d, t);

  return vec2(t, ray);
}

vec4 borders(vec2 u) {
    return vec4(
        u.x,             // distance from left
        1.0 - u.x,       // distance from right
        u.y,             // distance from bottom
        1.0 - u.y        // distance from top
    );
}

vec4 deviceDepthPixelDimension(vec2 u) {
    vec2 p = vec2(0.5) - u;

    float r = length(p) * 2.0;
    float a = atan(p.y, p.x);
    float f = cos(a * 3.0);

    vec4 wall = borders(u);  // NEW: How close to left/right or top/bottom
    float depth = min(wall.x, wall.y);  // use closest edge

    return vec4(r, a, f, depth);  // now you have screen-depth too!
}

float computeGlowFactor(float s) {
	return s * 0.1;
}

void main(){
    vec2 u = gl_FragCoord.xy/resolution.xy;
    vec3 color = vec3(0.0);

    float glow = computeGlowFactor(3.67);
    vec4 device = deviceDepthPixelDimension(u);
    float d = device.w;
    float r = device.x;
    float a = device.y;
    float f = device.z;

    // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(u.x * right + u.y * up + 1.5 * forward);

  // March
  vec2 renderer = raymarch(ro, rd);
  float t = renderer.x;
  float ray = renderer.y;
  vec3 p = ro + rd * t+(time)*sin(d);
  vec3 terrain = terrainColor(p, t);//+dgv;
    
  color = vec3( 1.-smoothstep(f,f+0.02,r) );
  color = vec3(terrain.x, (terrain.y*terrain.x), terrain.z+r/time)/r*(glow);

  gl_FragColor = vec4(color, 1.0);
}





// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
vec2 resolution = u_resolution.xy;
float time = u_time;
// Blue Skies

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001
vec3 dgv;

vec4 borders(vec2 u) {
    return vec4(
        u.x,             // distance from left
        1.0 - u.x,       // distance from right
        u.y,             // distance from bottom
        1.0 - u.y        // distance from top
    );
}

vec4 deviceDepthPixelDimension(vec2 u) {
    vec2 p = vec2(0.5) - u;

    float r = length(p) * 2.0;
    float a = atan(p.y, p.x);
    float f = cos(a * 3.0);

    vec4 wall = borders(u);  // NEW: How close to left/right or top/bottom
    float depth = min(wall.x, wall.y);  // use closest edge

    return vec4(r, a, f, depth);  // now you have screen-depth too!
}

// === Fractal Hill Pattern ===
float fractalHill(float t) {
  float total = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  float persistence = 0.5;

  for (int i = 0; i < 4; i++) {
    total += sin(t * frequency * 3.14159) * amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return total * 0.5 + 0.5; // normalize to [0,1]
}

// Terrain height using XZ
float terrainHeight(vec2 posXZ) {
  return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
}

// Usage
float getHeight(float t) {
  return fractalHill(t); // fractal height
}

float hash21(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 78.233);
    return fract(p.x * p.y);
}

float ripple(float t) {
  return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
}

float hillTerrain(float t) {
  return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
}

vec3 path (vec3 startPos, vec3 endPos, float t){
  return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
}

float linearTerrainSDF(vec3 p) {
  // simulate terrain along X
  float h = fractalHill(p.x);
  return p.y - h; // above = positive, below = negative
}

// 3D terrain SDF
float terrainSDF(vec3 p) {
  float h = terrainHeight(p.xz);
  return p.y - h;
}

float terrainVolumeSDF(vec3 p) {
  float h = fract(terrainHeight(p.xz)); 
  return p.y - h;
}

float sdCylinder(vec3 p, float h, float r) {
    vec3 q = fract(p);
    float lt = linearTerrainSDF(p);
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float treeSDF(vec3 p) {
    // Distribute trees periodically over terrain
    vec2 cell = floor(p.xz * 2.0); // spacing
    vec3 localP = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
    localP.y -= terrainHeight(cell + 0.5); // offset by terrain

    float trunk = sdCylinder(localP,  0.5, 0.05); // trunk
    return trunk;
}

float foliageSDF(vec3 p, vec3 base, float rnd) {
    float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
    vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
    return length(p - canopyCenter) - 0.15; // sphere canopy
}

float sceneSDF(vec3 p) {
    vec3 q = fract(p);
    float terrain = terrainVolumeSDF(p);
    float tree = treeSDF(p);
    float foliage = min(foliageSDF(q, (log(q)), tree), tree);
    return min(min(terrain, tree), foliage);
}

// Estimate normal from SDF
vec3 computeNormal(vec3 p) {
  float d = terrainVolumeSDF(p);
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    terrainVolumeSDF(p + e.xyy) - d,
    terrainVolumeSDF(p + e.yxy) - d,
    terrainVolumeSDF(p + e.yyx) - d
  ));
}

vec3 terrainColor(vec3 p, float d) {
  // Shading
  vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2+time) * diff;
  } else {
    color = vec3(0.6, 0.7, 1.0); // sky
  }
    return color;
}

float rayPower(vec3 p, float d, float t) {
  float depthFactor = 0.064;
  float ray = t * 0.2 * depthFactor;
  vec3 color;

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;

    float treeDist = treeSDF(p);
    if (treeDist < 0.02) {
      color = vec3(0.25, 0.1, 0.05);
    }

    float canopy = foliageSDF(p, vec3(0.0), hash21(p.xz));
    if (canopy < 0.03) {
      color = vec3(0.1, 0.4, 0.1);
    }

  } else {
    color = vec3(0.6, 0.8, 1.0); // base sky tint
  }

  return ray;
}

vec2 raymarch(vec3 ro, vec3 rd) {
  float t = 0.0; // Total Distance Travelled By Ray
  dgv = vec3(t);
  vec3 p; // declared outside loop so it's accessible after
  float d = 0.0;

  for (int i = 0; i < 80; i++) {
    p = ro + rd * t;
    d = min(terrainVolumeSDF(p+t), sceneSDF(p));
    if (d < 0.001 || t > 100.0) break;

    t += d;
    dgv = vec3(i) / 80.0;
  }
  float ray = rayPower(p, d, t);

  return vec2(t, ray);
}

float computeGlowFactor(float s) {
	return s * 0.1;
}

void main(){
    vec2 u = gl_FragCoord.xy/resolution.xy;
    vec3 color = vec3(0.0);

    float glow = computeGlowFactor(3.67);
    vec4 device = deviceDepthPixelDimension(u);
    float d = device.w;
    float r = device.x;
    float a = device.y;
    float f = device.z;

    // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(u.x * right + u.y * up + 1.5 * forward);

  // March
  vec2 renderer = raymarch(ro, rd);
  float t = renderer.x;
  float ray = renderer.y;
  vec3 p = (ro+time) + (rd+(t)) * t+(time)-sin(t);
  vec3 terrain = terrainColor(p, t);//+dgv;
    
  color = vec3( 1.-smoothstep(f,f+0.02,r) );
    float rt = r*(glow);
  color = (vec3(terrain.y*a, (terrain.y*terrain.x*a),(terrain.z)/time)/(rt/.6)*(glow)/a);
  // color = (vec3(terrain.x*a, (terrain.y*terrain.x*a/glow), terrain.z+r/time)/r*(glow)/a);

  gl_FragColor = vec4(color, 1.0);
}


h









// Firey Cave
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
vec2 mousePosition = u_mouse;
vec2 resolution = u_resolution;
float time = u_time;


#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001
vec3 dgv;

float hash21(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 78.233);
    return fract(p.x * p.y);
}

// === Fractal Hill Pattern ===
float fractalHill(float t) {
  float total = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  float persistence = 0.5;

  for (int i = 0; i < 4; i++) {
    total += sin(t * frequency * 3.14159) * amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return total * 0.5 + 0.5; // normalize to [0,1]
}

// Terrain height using XZ
float terrainHeight(vec2 posXZ) {
  return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
}

// Usage
float getHeight(float t) {
  return fractalHill(t); // fractal height
}

float sdBox( vec3 p, vec3 b ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float ripple(float t) {
  return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
}

float hillTerrain(float t) {
  return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
}

// Define a sunken path height profile (e.g., ditch-like dip)
float pathProfile(float t) {
  return -0.3 * smoothstep(0.2, 0.8, t) * (1.0 - smoothstep(0.2, 0.8, t));
}

float terrainWithPath(float t) {
  float base = hillTerrain(t);
  float path = pathProfile(t);
  return min(base, path); // path dips below terrain
}

vec3 path (vec3 startPos, vec3 endPos, float t){
  return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
}

float pathSDF(vec3 p) {
  // Local coords centered at trench along X, width/depth/length defined by box
  vec3 boxSize = vec3(5.0, 0.3, 1.0); // width, depth, length
  vec3 center = vec3(0.0, -0.15, 0.0); // lower the box trench into terrain
  return sdBox(p - center, boxSize);  // classic box SDF
}

float linearTerrainSDF(vec3 p) {
  // simulate terrain along X
  float h = fractalHill(p.x);
  return p.y - h; // above = positive, below = negative
}

// 3D terrain SDF
float terrainSDF(vec3 p) {
  float h = terrainHeight(p.xz);
  return p.y - h;
}

float terrainWithCarvedPath(vec3 p) {
  float terrain = terrainSDF(p);
  float path = pathSDF(p);
  return max(-path, terrain); // subtract path from terrain
}

float terrainVolumeSDF(vec3 p) {
    float tr = terrainSDF(p);
  float h = terrainHeight(p.xz); 
  // h   -=terrainWithPath(h)+min(hillTerrain(h),pathProfile(h));
    h *=1./-(tr);//To make sure terrain is down, terrain would be in the blue zone and upside down
  return p.y - h;
}

float sdCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float treeSDF(vec3 p) {
    // Distribute trees periodically over terrain
    vec2 cell = floor(p.xz * 2.0); // spacing
    vec3 localP = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
    localP.y -= terrainHeight(cell + 0.5); // offset by terrain

    float trunk = sdCylinder(localP,  0.5, 0.05); // trunk
    return trunk;
}

float foliageSDF(vec3 p, vec3 base, float rnd) {
    float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
    vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
    return length(p - canopyCenter) - 0.15; // sphere canopy
}

float sceneSDF(vec3 p) {
    vec3 q = fract(p);
    float terrain = terrainVolumeSDF(p);
    float tree = treeSDF(p);
    float foliage = min(foliageSDF(q, (log(q)), tree), tree);
    return min(min(terrain, tree), foliage);
}

// Estimate normal from SDF
vec3 computeNormal(vec3 p) {
  float d = terrainVolumeSDF(p);
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    terrainVolumeSDF(p + e.xyy) - d,
    terrainVolumeSDF(p + e.yxy) - d,
    terrainVolumeSDF(p + e.yyx) - d
  ));
}

vec3 terrainColor(vec3 p, float d) {
  vec3 color;

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;

    if (treeSDF(p) < 0.02) {
      color = vec3(0.25, 0.1, 0.05); // trunk
    }

    if (foliageSDF(p, vec3(0.0), hash21(p.xz)) < 0.03) {
      color = vec3(0.1, 0.4, 0.1); // canopy
    }

  } else {
    color = vec3(0.6, 0.8, 1.0); // sky

  }

  return color;
}

float rayPower(vec3 p, float d, float t) {
  float depthFactor = 0.064;
  float ray = t * 0.2 * depthFactor;
  vec3 color;

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;

    float treeDist = treeSDF(p);
    if (treeDist < 0.02) {
      color = vec3(0.25, 0.1, 0.05);
    }

    float canopy = foliageSDF(p, vec3(0.0), hash21(p.xz));
    if (canopy < 0.03) {
      color = vec3(0.1, 0.4, 0.1);
    }

  } else {
    color = vec3(0.6, 0.8, 1.0); // base sky tint
  }

  return ray;
}

vec2 raymarch(vec3 ro, vec3 rd) {
  float t = 0.0; // Total Distance Travelled By Ray
  dgv = vec3(t);
  vec3 p; // declared outside loop so it's accessible after
  float d = 0.0;

  for (int i = 0; i < 80; i++) {
    p = ro + rd * t;
    d = min(terrainVolumeSDF(p), sceneSDF(p));
    // d = min(terrainVolumeSDF(p), sceneSDF(p)+(time*0.1));
    float trp = terrainWithCarvedPath(p);
    if (d < 0.001 || t > 100.0) break;

    t += d;
    dgv = vec3(i) / 80.0;
  }
  float ray = rayPower(p, d, t);

  return vec2(t, ray);
}

vec4 borders(vec2 u) {
    return vec4(
        u.x,             // distance from left
        1.0 - u.x,       // distance from right
        u.y,             // distance from bottom
        1.0 - u.y        // distance from top
    );
}

vec4 deviceDepthPixelDimension(vec2 u) {
    vec2 p = vec2(0.5) - u;

    float r = length(p) * 2.0;
    float a = atan(p.y, p.x);
    float f = cos(a * 3.0);

    vec4 wall = borders(u);  // NEW: How close to left/right or top/bottom
    float depth = min(wall.x, wall.y);  // use closest edge

    return vec4(r, a, f, depth);  // now you have screen-depth too!
}

float computeGlowFactor(float s) {
	return s * 0.1;
}


void main(){
    vec2 u = gl_FragCoord.xy/resolution.xy;
    vec3 color = vec3(0.0);

    float glow = computeGlowFactor(6.67);
    vec4 device = deviceDepthPixelDimension(u);
    float d = device.w;
    float r = device.x;
    float a = device.y;
    float f = device.z;

    // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(u.x * right + u.y * up + 1.5 * forward);

  // March
  vec2 renderer = raymarch(ro, rd);
  float t = renderer.x;
  float ray = renderer.y;
  vec3 p = (ro) + (rd) * t+(time*0.1);
  vec3 terrain = terrainColor(p, t);//+dgv;
    // float trp = terrainWithCarvedPath(p);
    // terrain *= trp;
    
float mc = (t*ray);
float rgR = terrain.x*mc;
float rgG = (terrain.y*terrain.x);
float rgB = terrain.z*r/time;
float rg = (glow)/r;


  color = vec3( 1.-smoothstep(f,f+0.02,r) );
  color = vec3(rg, rgG , rgR)*rg;

    // color *= ;
  gl_FragColor = vec4(color, 1.0);
}


// void main(){
//     vec2 st = gl_FragCoord.xy/u_resolution.xy;
//     vec3 color = vec3(0.0);

//     vec2 pos = vec2(0.5)-st;

//     float r = length(pos)*2.0;
//     float a = atan(pos.y,pos.x);

//     float f = cos(a*3.);
//     // f = abs(cos(a*3.));
//     // f = abs(cos(a*2.5))*.5+.3;
//     // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
//     // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

//     color = vec3( 1.-smoothstep(f,f+0.02,r) );

//     gl_FragColor = vec4(color, 1.0);
// }

// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
float time = u_time;
vec2 resolution = u_resolution.xy;

// Mystic Cave

#ifdef GL_ES
precision mediump float;
#endif

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001
vec3 dgv;

float hash21(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 78.233);
    return fract(p.x * p.y);
}
// === Fractal Hill Pattern ===
float fractalHill(float t) {
  float total = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  float persistence = 0.5;

  for (int i = 0; i < 4; i++) {
    total += sin(t * frequency * 3.14159) * amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return total * 0.5 + 0.5; // normalize to [0,1]
}

// Terrain height using XZ
float terrainHeight(vec2 posXZ) {
  return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
}

// Usage
float getHeight(float t) {
  return fractalHill(t); // fractal height
}

float sdBox( vec3 p, vec3 b ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float sdCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float hillTerrain(float t) {
  return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
}

vec3 path (vec3 startPos, vec3 endPos, float t){
  return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
}

float linearTerrainSDF(vec3 p) {
  // simulate terrain along X
  float h = fractalHill(p.x);
  return p.y - h; // above = positive, below = negative
}

// 3D terrain SDF
float terrainVolumeSDF(vec3 p) {
  float h = terrainHeight(p.xz); // 2D hill over XZ
  return p.y - h;
}

float treeSDF(vec3 p) {
    // Distribute trees periodically over terrain
    vec2 cell = floor(p.xz * 2.0); // spacing
    vec3 localP = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
    localP.y -= terrainHeight(cell + 0.5); // offset by terrain

    float trunk = sdCylinder(localP,  0.5, 0.05); // trunk
    return trunk;
}

float foliageSDF(vec3 p, vec3 base, float rnd) {
    float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
    vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
    // vec3 q = fract(p)-0.5;
    return length(p - canopyCenter) - 0.15; // sphere canopy
}

float ripple(float t) {
  return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
}

float sceneSDF(vec3 p) {
    vec3 q = fract(p);
    float terrain = terrainVolumeSDF(p);
    float tree = treeSDF(p);
    float foliage = min(foliageSDF(q, (log(q)), tree), tree);
    return min(min(terrain, tree), foliage);
}

// Estimate normal from SDF
vec3 computeNormal(vec3 p) {
  float d = terrainVolumeSDF(p);
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    terrainVolumeSDF(p + e.xyy) - d,
    terrainVolumeSDF(p + e.yxy) - d,
    terrainVolumeSDF(p + e.yyx) - d
  ));
}

vec3 terrainColor(vec3 p, float d) {
  vec3 color;

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;

    if (treeSDF(p) < 0.02) {
      color = vec3(0.25, 0.1, 0.05); // trunk
    }

    if (foliageSDF(p, vec3(0.0), hash21(p.xz)) < 0.03) {
      color = vec3(0.1, 0.4, 0.1); // canopy
    }

  } else {
    color = vec3(0.6, 0.8, 1.0); // sky

  }

  return color;
}

float rayPower(vec3 p, float d, float t) {
  float depthFactor = 0.064;
  float ray = t * 0.2 * depthFactor;
  vec3 color;

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;

    float treeDist = treeSDF(p);
    if (treeDist < 0.02) {
      color = vec3(0.25, 0.1, 0.05);
    }

    float canopy = foliageSDF(p, vec3(0.0), hash21(p.xz));
    if (canopy < 0.03) {
      color = vec3(0.1, 0.4, 0.1);
    }

  } else {
    color = vec3(0.6, 0.8, 1.0); // base sky tint
  }

  return ray;
}

vec2 raymarch(vec3 ro, vec3 rd) {
  float t = 0.0; // Total Distance Travelled By Ray
  dgv = vec3(t);
  vec3 p; // declared outside loop so it's accessible after
  float d = 0.0;
  float ray;

  for (int i = 0; i < 80; i++) {
    p = ro + rd * t;
    d = min(terrainVolumeSDF(p), sceneSDF(p));
    d += 0.;
    if (d < 0.001 || t > 100.0) break;

    t += d;
    dgv = vec3(i) / 80.0;
  ray= tan(rayPower(p, d, -sceneSDF(p-(time*0.1))));
  }

  return vec2(t, ray);
}

vec4 borders(vec2 u) {
    return vec4(
        u.x,             // distance from left
        1.0 - u.x,       // distance from right
        u.y,             // distance from bottom
        1.0 - u.y        // distance from top
    );
}

vec4 deviceDepthPixelDimension(vec2 u) {
    vec2 p = vec2(0.5) - u;

    float r = length(p) * 2.0;
    float a = atan((p.y), sin(p.x*2.))*sin(1.9*r);
    a = atan((p.y)*12.+p.y*time, sin(p.x*2.))*sin(.9*r); // circle ring
    float f = cos(a*3.0+time);

    // f = abs(cos(a*3.));
    // f = abs(cos(a*2.5))*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
    // float shape = 1.-smoothstep(f,f+0.02,r);

    vec4 wall = borders(u);  // NEW: How close to left/right or top/bottom
    float depth = min(wall.x, wall.y);  // use closest edge

    return vec4(r, a, f, depth);  // now you have screen-depth too!
}

float computeGlowFactor(float s) {
return s * 0.1;
}


void main(){
    vec2 u = gl_FragCoord.xy/resolution.xy;
    vec3 color = vec3(0.0);

    float glow = computeGlowFactor(5.67);
    vec4 device = deviceDepthPixelDimension(u);
    float d = device.w;
    float r = device.x;
    float a = device.y;
    float f = device.z;

    // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(u.x * right + u.y * up + 1.5 * forward);

  // March
  vec2 renderer = raymarch(ro, rd);
  float t = renderer.x;
  float ray = renderer.y;
  vec3 p = ro*a + rd * t+(time*0.1);
  vec3 terrain = terrainColor(p+(time*0.1*ray), t);//+dgv;
    float rt = r/time;
    float rg = r*glow;
    float hg = r+glow-0.1;
    float rgR = terrain.x/a/r;
    float rgG = terrain.y*terrain.x+glow;
    float rgB = terrain.z+r/time;

    color = vec3(rgR, (rgG-r-0.1), rgB)/r*(glow);
    rgR = terrain.x/t/r;
    color = vec3(rgR, (rgG-r-0.1), rgB)/r*(glow); // Butter Mist
    rgR = terrain.x/a/r;
    color = vec3(rgR, (rgG-0.1), rgB)/r*(glow); // Blue Milk
    color = vec3(rgR, (rgG-0.1), rgB)/r*(glow); // Blue Milk
    rgB = terrain.z+r;
    color = vec3(rgR, (rgG-0.1), rgB)/r*(glow); // Blue Milk

    gl_FragColor = vec4(color, 1.0);
}


// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
float time = u_time;
vec2 resolution = u_resolution.xy;

// Mystic Cave

#ifdef GL_ES
precision mediump float;
#endif

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001
vec3 dgv;

float hash21(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 78.233);
    return fract(p.x * p.y);
}
// === Fractal Hill Pattern ===
float fractalHill(float t) {
  float total = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;
  float persistence = 0.5;

  for (int i = 0; i < 4; i++) {
    total += sin(t * frequency * 3.14159) * amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return total * 0.5 + 0.5; // normalize to [0,1]
}

// Terrain height using XZ
float terrainHeight(vec2 posXZ) {
  return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
}

// Usage
float getHeight(float t) {
  return fractalHill(t); // fractal height
}

float sdBox( vec3 p, vec3 b ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float sdCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float hillTerrain(float t) {
  return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
}

vec3 path (vec3 startPos, vec3 endPos, float t){
  return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
}

float linearTerrainSDF(vec3 p) {
  // simulate terrain along X
  float h = fractalHill(p.x);
  return p.y - h; // above = positive, below = negative
}

// 3D terrain SDF
float terrainVolumeSDF(vec3 p) {
  float h = terrainHeight(p.xz); // 2D hill over XZ
  return p.y - h;
}

float treeSDF(vec3 p) {
    // Distribute trees periodically over terrain
    vec2 cell = floor(p.xz * 2.0); // spacing
    vec3 localP = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
    localP.y -= terrainHeight(cell + 0.5); // offset by terrain

    float trunk = sdCylinder(localP,  0.5, 0.05); // trunk
    return trunk;
}

float foliageSDF(vec3 p, vec3 base, float rnd) {
    float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
    vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
    // vec3 q = fract(p)-0.5;
    return length(p - canopyCenter) - 0.15; // sphere canopy
}

float ripple(float t) {
  return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
}

float sceneSDF(vec3 p) {
    vec3 q = fract(p);
    float terrain = terrainVolumeSDF(p);
    float tree = treeSDF(p);
    float foliage = min(foliageSDF(q, (log(q)), tree), tree);
    return min(min(terrain, tree), foliage);
}

// Estimate normal from SDF
vec3 computeNormal(vec3 p) {
  float d = terrainVolumeSDF(p);
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    terrainVolumeSDF(p + e.xyy) - d,
    terrainVolumeSDF(p + e.yxy) - d,
    terrainVolumeSDF(p + e.yyx) - d
  ));
}

vec3 terrainColor(vec3 p, float d) {
  vec3 color;

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;

    if (treeSDF(p) < 0.02) {
      color = vec3(0.25, 0.1, 0.05); // trunk
    }

    if (foliageSDF(p, vec3(0.0), hash21(p.xz)) < 0.03) {
      color = vec3(0.1, 0.4, 0.1); // canopy
    }

  } else {
    color = vec3(0.6, 0.8, 1.0); // sky

  }

  return color;
}

float rayPower(vec3 p, float d, float t) {
  float depthFactor = 0.064;
  float ray = t * 0.2 * depthFactor;
  vec3 color;

  if (d < MAX_DIST) {
    vec3 normal = computeNormal(p);
    float diff = clamp(dot(normal, normalize(vec3(0.3, 1.0, 0.5))), 0.0, 1.0);
    color = vec3(0.3, 0.6, 0.2) * diff;

    float treeDist = treeSDF(p);
    if (treeDist < 0.02) {
      color = vec3(0.25, 0.1, 0.05);
    }

    float canopy = foliageSDF(p, vec3(0.0), hash21(p.xz));
    if (canopy < 0.03) {
      color = vec3(0.1, 0.4, 0.1);
    }

  } else {
    color = vec3(0.6, 1.8, 1.0); // base sky tint
  }

  return ray;
}

vec2 raymarch(vec3 ro, vec3 rd) {
  float t = 0.0; // Total Distance Travelled By Ray
  dgv = vec3(t);
  vec3 p; // declared outside loop so it's accessible after
  float d = 0.0;
  float ray;

  for (int i = 0; i < 80; i++) {
    p = ro + rd * t;
    d = min(terrainVolumeSDF(p), sceneSDF(p));
    d += 0.;
    if (d < 0.001 || t > 100.0) break;

    t += d;
    dgv = vec3(i) / 80.0;
  ray = tan(rayPower(p, d, -sceneSDF(p)));
  ray /= tan(rayPower(p, d, -sceneSDF(p-(time*0.1))));
  // ray /= tan(rayPower(p, d, -sceneSDF(p-(t-time*0.1))));
  // ray = tan(rayPower(p, d, -sceneSDF(p-(time*0.01))));
  // ray = tan(rayPower(p, d, t-sceneSDF(p-(time*0.01))));
  // ray = tan(rayPower(p, t, -sceneSDF(p-(d-time*0.1))));
  // ray = tan(rayPower(p, d, t-sceneSDF(p-(time*0.01))));
  // ray = tan(rayPower(p, d, d-sceneSDF(p-(d-time*0.01))));
  // ray = tan(rayPower(p, d, t-sceneSDF(p-(t-time*0.01))));
  }

  return vec2(t, ray);
}

vec4 borders(vec2 u) {
    return vec4(
        u.x,             // distance from left
        1.0 - u.x,       // distance from right
        u.y,             // distance from bottom
        1.0 - u.y        // distance from top
    );
}

vec4 deviceDepthPixelDimension(vec2 u) {
    vec2 p = vec2(0.5) - u;

    float r = length(p) * 2.0;
    float a = atan((p.y), sin(p.x*2.))*sin(1.9*r);
    a = atan((p.y)*12.+p.y*time, sin(p.x*2.))*sin(.9*r); // circle ring
    float f = cos(a*3.0+time);

    // f = abs(cos(a*3.));
    // f = abs(cos(a*2.5))*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
    // float shape = 1.-smoothstep(f,f+0.02,r);

    vec4 wall = borders(u);  // NEW: How close to left/right or top/bottom
    float depth = min(wall.x, wall.y);  // use closest edge

    return vec4(r, a, f, depth);  // now you have screen-depth too!
}

float computeGlowFactor(float s) {
return s * 0.1;
}


void main(){
    vec2 u = gl_FragCoord.xy/resolution.xy;
    vec3 color = vec3(0.0);

    float glow = computeGlowFactor(5.67);
    vec4 device = deviceDepthPixelDimension(u);
    float d = device.w;
    float r = device.x;
    float a = device.y;
    float f = device.z;

    // Camera setup
  vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
  vec3 up = cross(forward, right);
  vec3 rd = normalize(u.x * right + u.y * up + 1.5 * forward);

  // March
  vec2 renderer = raymarch(ro, rd);
  float t = renderer.x;
  float ray = renderer.y;
  vec3 p = ro*a + rd * t+(time*0.1);
  vec3 terrain = terrainColor(p+(time*0.1*ray), t);//+dgv;
    float rt = r/time;
    float rg = r*glow;
    float hg = r+glow-0.1;
    float rgR = terrain.x/a/r;
    float rgG = terrain.y*terrain.x+glow;
    float rgB = terrain.z+r/time;

    color = vec3(rgR, (rgG-r-0.1), rg)*(glow-0.2)/r;
    rgR = terrain.x/t/r;
    color = vec3(rgR, (rgG-r-0.1), rg)*(glow-0.2)/r; // Butter Mist
    rgR = terrain.x/a/r;
    color = vec3(rgR, (rgG-0.1), rg)*(glow-0.2)/r; // Blue Milk
    color = vec3(rgR, (rgG-0.1), rg)*(glow-0.2)/r; // Blue Milk
    rgB = terrain.z+r;
    color = vec3(rgR, (rgG-0.1), rgB)*(glow-0.2)/r; // Blue Milk

    gl_FragColor = vec4(color, 1.0);
}












// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
float time = u_time;
vec2 mousePosition = u_mouse;
vec2 resolution = u_resolution.xy;


// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
float time = u_time;
vec2 mousePosition = u_mouse;
vec2 resolution = u_resolution.xy;

        #define MAX_STEPS 100
        #define MAX_DIST 100.0
        #define SURF_DIST 0.001
        
        // === Fractal Hill Pattern ===
        float fractalHill(float t) {
          float total = 0.0;
          float amplitude = 1.0;
          float frequency = 1.0;
          float persistence = 0.5;
        
          for (int i = 0; i < 4; i++) {
            total += sin(t * frequency * 3.14159) * amplitude;
            amplitude *= persistence;
            frequency *= 2.0;
          }
        
          return total * 0.5 + 0.5; // normalize to [0,1]
        }
        
        // Terrain height using XZ
        float terrainHeight(vec2 posXZ) {
          return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
        }
        
        // Usage
        float getHeight(float t) {
          return fractalHill(t); // fractal height
        }

        float sdCylinder(vec3 p, float h, float r) {
            vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
            return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
        }
        
        float ripples(float t) {
          return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
        }
        
        float hillTerrain(float t) {
          return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
        }
        
        vec3 getPath (vec3 startPos, vec3 endPos, float t){
          return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
        }
        
        float linearTerrainSDF(vec3 p) {
          // simulate terrain along X
          float h = fractalHill(p.x+time);
          return p.y - h; // above = positive, below = negative
        }

        
        float terrainVolumeSDF(vec3 p) {
          float h = terrainHeight(p.xz); // 2D hill over XZ
          return p.y - h;
        }
        float treeSDF(vec3 p) {
            p.z -= time;
            p =fract(p);
            // Distribute trees periodically over terrain
            vec2 cell = floor(p.xz * 2.0); // spacing
            vec3 pos = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
            pos.y -= terrainHeight(cell + 0.5); // offset by terrain

            float trunk = sdCylinder(pos,  0.5, .05); // trunk
            return trunk;
        }

        float foliageSDF(vec3 p, vec3 base, float rnd) {
            float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
            vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
            // vec3 q = fract(p)-0.5;
            return length(p - canopyCenter) - 0.15; // sphere canopy
        }
        float forestSDF(vec3 p) {
            float terrain = terrainVolumeSDF(p);
            float tree = treeSDF(p);
            float foliage = min(foliageSDF(p, (vec3(tree)), terrain), tree);
            // foliage = min(foliageSDF(p, -log(p), terrain), tree);
            // return min(min(terrain, tree), foliage);
            // return min(min(terrain, tree), foliage);
            return min((terrain, tree), foliage);
        }

        // Estimate normal from SDF
        vec3 computeNormal(vec3 p) {
          float d = terrainVolumeSDF(p)+forestSDF(p);
          vec2 e = vec2(0.001, 0.0);
          return normalize(vec3(
            terrainVolumeSDF(p + e.xyy) - d,
            terrainVolumeSDF(p + e.yxy) - d,
            terrainVolumeSDF(p + e.yyx) - d
          ));
        }
        
        vec3 terrainColor(vec3 p, float d) {
          // Shading
          vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
          if (d < MAX_DIST) {
            vec3 normal = computeNormal(p);
            float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
            color = vec3(0.3, 0.6, 0.2) * diff;
          } else {
            color = vec3(0.6, 0.8, 1.0); // sky
          }
            return color;
        }

        // Raymarching algorithm
        float renderer(vec3 ro, vec3 rd) {
          float t = 0.0;
          for (int i = 0; i < MAX_STEPS; i++) {
            vec3 p = ro + rd * t;
            float d = terrainVolumeSDF(p) + linearTerrainSDF(p);
            if (d < SURF_DIST || t > MAX_DIST) break;
            t += d;
          }
          return t;
        }
        
        vec4 raymarch(vec3 ro, vec3 rd) {
          float depthFactor = 0.064;
          float t = 0.0; // Total Distance Travelled By Ray
          vec3 depthGreyValue = vec3(t);
          vec3 p; // declared outside loop so it's accessible after
          float d = 0.0;
          vec3 pth = getPath(ro, rd, t) ;
          
          for (int i = 0; i < 80; i++) {
            p = ro + rd * t;
            float d = terrainVolumeSDF(p)* linearTerrainSDF(p+pth);// LandScape;
            d = terrainVolumeSDF(p)+ linearTerrainSDF(p+pth);// Coniferous Forests
            // d = terrainVolumeSDF(p)* linearTerrainSDF(p+pth)+hillTerrain(p.y); // Riparian Forest 
              d = forestSDF(p);
              // d=forestSDF(p+pth)+forestSDF(p)+linearTerrainSDF(p+pth);
            // d = terrainVolumeSDF(p)* linearTerrainSDF(p+pth)+hillTerrain(p.z); //Snow Grassland
            // d = (terrainVolumeSDF(p)+ linearTerrainSDF(p+pth)+hillTerrain(p.z)); // Plain Field
            if (d < 0.001 || t > 100.0) break;
        
            t += d;
            depthGreyValue = vec3(i) / 80.0;
          }
        
          float ray = t * 0.2 * depthFactor;
          float rpl = ripples(ray*sin(time+0.7));
          
          // ðŸŒ¿ Base shading â€” default grass tint
          vec3 color = depthGreyValue * vec3(0.6, .85, 0.4);
          vec3 landScape = terrainColor(p, t);
          // color = depthGreyValue * landScape;
          // vec3 cloudyLandScape = terrainColor(p, t*rpl);
          // vec3 foggyLandScape = terrainColor(p, t/rpl);
          // color = depthGreyValue * landScape;
          // color = depthGreyValue / cloudyLandScape;// Wind AND 
          // color = depthGreyValue * foggyLandScape; // FloodedDelta
          // vec3 rayColor= rayPower(p, d, t);
        
          return vec4(color, ray);
          
        }
        
        float sdSun(vec2 u) {
          vec2 p = vec2(0.5)-u;
          return length(p)*2.0;
        }
        
        vec3 sunLight(vec2 uv) {
            float d = sdSun(uv);  // you can vary this radius
            float mask = 1.0 - smoothstep(0.0, 0.02, d);
            vec3 color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 0.9, 1.0), sin(time * 0.25) * 0.5 + 0.5);
            return color * mask;
        }
        
        vec3 dimensions(vec2 u) {
          vec2 p = vec2(0.5)-u;
      
          float r = length(p)*2.0;  // This can serve as the Sun since sdf circle need only r
          float a = atan(p.y,p.x);
        
          float f = cos(a*3.);
          // f = abs(cos(a*3.));
          // f = abs(cos(a*2.5))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
          return vec3(r, a, f);
          }
      
        void main(){
          vec2 uv = gl_FragCoord.xy/resolution.xy;

          vec3 specs = dimensions(uv);
          float r = specs.x;
          float a = specs.y;
          float f = specs.z;
          float sun = sdSun(uv);
            
          // Camera setup
          vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
          vec3 lookAt = vec3(0.0, 0.0, 0.0);
          vec3 forward = normalize(lookAt - ro);
          vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
          vec3 up = cross(forward, right);
          vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);
        
          // March
          vec4 renderer = raymarch(ro, rd);
          // float d = renderer(ro, rd+time);
          // float dist = march.w;
          // vec3 p = ro + rd * dist;
        
        
          vec3 color = vec3( 1.-smoothstep(f,f+0.02,r) );
          // color *= d;
          
          color = r-vec3(renderer.w-r, renderer.y, renderer.z)-renderer.z/(sun);
          // color = sunLight(uv);
          // Optional: apply polar distortion
          // color *= 0.5 + 0.5 * polarEffect;
          gl_FragColor = vec4(color, 1.0);
        }

// void main(){
//     vec2 st = gl_FragCoord.xy/u_resolution.xy;
//     vec3 color = vec3(0.0);

//     vec2 pos = vec2(0.5)-st;

//     float r = length(pos)*2.0;
//     float a = atan(pos.y,pos.x);

//     float f = cos(a*3.);
//     // f = abs(cos(a*3.));
//     // f = abs(cos(a*2.5))*.5+.3;
//     // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
//     // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

//     color = vec3( 1.-smoothstep(f,f+0.02,r) );

//     gl_FragColor = vec4(color, 1.0);
// }



// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com











// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
float time = u_time;
vec2 mousePosition = u_mouse;
vec2 resolution = u_resolution.xy;

        varying vec2 vUv;
        // uniform vec2 resolution;
        // uniform vec2 mousePosition;
        // uniform float time;
        uniform float hovered;
        uniform float sineTime;
        uniform float shapeFactor;
        uniform float explodeIntensity;

        #define MAX_STEPS 100
        #define MAX_DIST 100.0
        #define SURF_DIST 0.001
        vec3 dgv;
        
        // === Fractal Hill Pattern ===
        float fractalHill(float t) {
          float total = 0.0;
          float amplitude = 1.0;
          float frequency = 1.0;
          float persistence = 0.5;
        
          for (int i = 0; i < 4; i++) {
            total += sin(t * frequency * 3.14159) * amplitude;
            amplitude *= persistence;
            frequency *= 2.0;
          }
        
          return total * 0.5 + 0.5; // normalize to [0,1]
        }
        
        // Terrain height using XZ
        float terrainHeight(vec2 posXZ) {
          return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
        }
        
        // Usage
        float getHeight(float t) {
          return fractalHill(t); // fractal height
        }

        float sdCylinder(vec3 p, float h, float r) {
          vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
          return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
        }
        
        float ripples(float t) {
          return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
        }
        
        float hillTerrain(float t) {
          return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
        }
        
        vec3 getPath (vec3 startPos, vec3 endPos, float t){
          return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
        }
     
        float terrainVolumeSDF(vec3 p) {
          float h = terrainHeight(p.xz); // 2D hill over XZ
          return p.y - h;
        }

        float treeSDF(vec3 p) {
          p.z -= time;
          p =fract(p);
          // Distribute trees periodically over terrain
          vec2 cell = floor(p.xz * 2.0); // spacing
          vec3 pos = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
          pos.y -= terrainHeight(cell + 0.5); // offset by terrain

          float trunk = sdCylinder(pos,  0.5, .05); // trunk
          return trunk;
        }

        float foliageSDF(vec3 p, vec3 base, float rnd) {
          float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
          vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
          // vec3 q = fract(p)-0.5;
          return length(p - canopyCenter) - 0.15; // sphere canopy
        }

        float linearTerrainSDF(vec3 p) {
          // simulate terrain along X
          float h = fractalHill(p.y+(time*0.21)+ terrainVolumeSDF((p)));// Atlantic Deltas
            
          float r = ripples(h);
          h = fractalHill(p.y+(time*0.21)+ terrainVolumeSDF((p)));// Atlantic Deltas
          // float h = fractalHill(p.y+(time*0.1)+ treeSDF(fract(1.-p)));
          // h=r;
          return p.y - h; // above = positive, below = negative
        }

        float forestSDF(vec3 p) {
          float terrain = terrainVolumeSDF(p);
          float tree = treeSDF(p);
          float foliage = min(foliageSDF(p, (vec3(tree)), terrain), tree);
          // foliage = min(foliageSDF(p, -log(p), terrain), tree);
          // return min(min(terrain, tree), foliage);
          // return min(min(terrain, tree), foliage);
          return min((terrain, tree), foliage);
        }

        // Estimate normal from SDF
        vec3 computeNormal(vec3 p) {
          float d = terrainVolumeSDF(p)+forestSDF(p);
          vec2 e = vec2(0.001, 0.0);
          return normalize(vec3(
            terrainVolumeSDF(p + e.xyy) - d,
            terrainVolumeSDF(p + e.yxy) - d,
            terrainVolumeSDF(p + e.yyx) - d
          ));
        }
        
        vec3 terrainColor(vec3 p, float d) {
          // Shading
          vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
          if (d < MAX_DIST) {
            vec3 normal = computeNormal(p);
            float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
            color = vec3(0.3, 0.6, 0.2) * diff;
          } else {
            color = vec3(0.6, 0.8, 1.0); // sky
          }
            return color;
        }

        // Raymarching algorithm
        float renderer(vec3 ro, vec3 rd) {
          float t = 0.0;
          for (int i = 0; i < MAX_STEPS; i++) {
            vec3 p = ro + rd * t;
            float d = terrainVolumeSDF(p) + linearTerrainSDF(p);
            if (d < SURF_DIST || t > MAX_DIST) break;
            t += d;
          }
          return t;
        }
        
        vec4 raymarch(vec3 ro, vec3 rd) {
          float depthFactor = 0.064;
          float t = 0.0; // Total Distance Travelled By Ray
          vec3 depthGreyValue = vec3(t);
          vec3 p; // declared outside loop so it's accessible after 
          float ripple;
          float d = 0.0;
          vec3 path = getPath(ro, rd, t) ;
          
          for (int i = 0; i < 80; i++) {
            p = ro + rd * t;
            float d = terrainVolumeSDF(p)* linearTerrainSDF(p+path);// LandScape;
            d = terrainVolumeSDF(p)+ linearTerrainSDF(p+path);// Coniferous Forests
            // d = terrainVolumeSDF(p)* linearTerrainSDF(p+path)+hillTerrain(p.y); // Riparian Forest 
            d = forestSDF(p);
            d = treeSDF(p);
            d = getPath(ro, rd, p.x).y;
            d = linearTerrainSDF(p +path)+treeSDF(p); 
            // d+=forestSDF(p+path)+forestSDF(p)+linearTerrainSDF(p+path);
            // d = terrainVolumeSDF(p)+ linearTerrainSDF(p+path); //Snow Grassland
            // d = (terrainVolumeSDF(p)+ linearTerrainSDF(p+path)+hillTerrain(p.z)); // Plain Field
            if (d < 0.001 || t > 100.0) break;
        
            t += d;
            depthGreyValue = vec3(i) / 80.0;
          }
        
          float ray = t * 0.912 * depthFactor;
          ripple = ripples(ray*sin(time+0.7));
          
          // ðŸŒ¿ Base shading â€” default grass tint
          vec3 color = depthGreyValue * vec3(0.6, .85, 0.4);
          vec3 landScape = terrainColor(p, t);
          // color = depthGreyValue * landScape;
          // vec3 cloudyLandScape = terrainColor(p, t*ripple);
          // vec3 foggyLandScape = terrainColor(p, t/ripple);
          // color = depthGreyValue * landScape;
          // color = depthGreyValue / cloudyLandScape;// Wind AND 
          // color = depthGreyValue * foggyLandScape; // FloodedDelta
          // vec3 rayColor= rayPower(p, d, t);
        
          return vec4(color, ray);
        }
        
        float sdSun(vec2 u) {
          vec2 p = vec2(0.5)-u;
          return length(p)*2.0;
        }
        
        vec3 sunLight(vec2 uv) {
          float d = sdSun(uv);  // you can vary this radius
          float mask = 1.0 - smoothstep(0.0, 0.02, d);
          vec3 color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 0.9, 1.0), sin(time * 0.25) * 0.5 + 0.5);
          return color * mask;
        }
        
        vec3 dimensions(vec2 u) {
          vec2 pos = vec2(0.5)-u;
          vec3 p = vec3(pos, -9.0+time);
          float dx = distance(p.x, 0.0);
          float dy = distance(p.y, 0.0);
          float dz = distance(p.z, 0.0);
      
          float r = length(pos)*2.0; 
          float pzt = p.z*(time*0.00051);
          float a = atan(pos.y,tan(p.z+fract(pos.x+p.z)));
            
          float tdy = dy*cos(0.3*atan(pzt, a)); 
            
          // float ap = atan(p.y,atan(dx,tan(atan(a, atan(pzt, a)) )));
          //   a=ap-(p.z);
        
          float f = cos(a*3.)*sin(a*3.);
          // f = abs(cos(a*3.));
          f = abs(cos(a*5.5))*.5+.3-r/2.;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1-r;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5; 		 
         float s = 1.-smoothstep(f,f+0.02,r);
          return vec3(r, a, s);
          }
      
        void main(){
          vec2 uv = gl_FragCoord.xy/resolution.xy;

          // Normalize Mouse normalized to same space (assuming it's passed in already as [0, res])
          vec2 mouse = (mousePosition * 2.0 - 1.0); // Convert to [-1, 1] range

          vec3 specs = dimensions(uv);
          float r = specs.x;
          float a = specs.y;
          float v = specs.z;
          float sun = sdSun(uv);
            
          // Camera setup
          vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
          vec3 lookAt = vec3(0.0, 0.0, 0.0);
          vec3 forward = normalize(lookAt - ro);
          vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
          vec3 up = cross(forward, right);
          vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);
            vec3 color;
        
          // March
          vec4 renderer = raymarch(ro, rd);
          // float d = renderer(ro, rd+time);
          // float dist = march.w;
          // vec3 p = ro + rd * dist;
        
        
          // vec3 color = vec3( 1.-smoothstep(f,f+0.02,r) );
          // color *= d;
          
          vec3 shape = r-vec3((renderer.w-r), renderer.y, renderer.z)-renderer.z/(sun);
          color = shape;
          // color = sunLight(uv); 

          float absT =  abs(sin(sineTime));
          // Check if hovered is active or not
          if (hovered > 0.0) {
            // Mouse is hovering, apply mouse interaction effects
            float dist = distance(mousePosition, uv);
            float absT =  abs(sin(sineTime));
            // dist +=  absT;
            
            // Use the distance to influence the color (make mouse position cause a color shift)
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Makes the area closer to the mouse lighter (for visible effect)

            // Use distance to control the opacity
            float opacity = smoothstep(0.0, 0.5, dist); // Opacity decreases with distance from the mouse position
            
            // Optionally, add sineTime-based animation for extra dynamics
            color *= 0.5 + (0.5) * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and time
                
            gl_FragColor = vec4(color, opacity);
          } else {
            // Mouse is not hovering, apply default effect based on UV coordinates and distance
            float dist = distance(uv, vec2(0.5, 0.5)); // Default base distance, could be replaced with your original calculation
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Use original UV-distance-bacoloring
            color = shape; // Sliding movement 
            color *= (0.1371+v)+ (0.975) * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and sineTime
            float opacity = smoothstep(0.6, 0.8, 1.0);
            gl_FragColor = vec4(color, opacity); // Default behavior
          }  
          // gl_FragColor = vec4(color, 1.0);
        }
         
// void main(){
//     vec2 st = gl_FragCoord.xy/u_resolution.xy;
//     vec3 color = vec3(0.0);

//     vec2 pos = vec2(0.5)-st;

//     float r = length(pos)*2.0;
//     float a = atan(pos.y,pos.x);

//     float f = cos(a*3.);
//     // f = abs(cos(a*3.));
//     // f = abs(cos(a*2.5))*.5+.3;
//     // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
//     // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

//     color = vec3( 1.-smoothstep(f,f+0.02,r) );

//     gl_FragColor = vec4(color, 1.0);
// }



// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
float time = u_time;
vec2 mousePosition = u_mouse;
vec2 resolution = u_resolution.xy;

        varying vec2 vUv;
        // uniform vec2 resolution;
        // uniform vec2 mousePosition;
        // uniform float time;
        uniform float hovered;
        uniform float sineTime;
        uniform float shapeFactor;
        uniform float explodeIntensity;

        #define MAX_STEPS 100
        #define MAX_DIST 100.0
        #define SURF_DIST 0.001
        vec3 dgv;
        
        // === Fractal Hill Pattern ===
        float fractalHill(float t) {
          float total = 0.0;
          float amplitude = 1.0;
          float frequency = 1.0;
          float persistence = 0.5;
        
          for (int i = 0; i < 4; i++) {
            total += sin(t * frequency * 3.14159) * amplitude;
            amplitude *= persistence;
            frequency *= 2.0;
          }
        
          return total * 0.5 + 0.5; // normalize to [0,1]
        }
        
        // Terrain height using XZ
        float terrainHeight(vec2 posXZ) {
          return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
        }
        
        // Usage
        float getHeight(float t) {
          return fractalHill(t); // fractal height
        }

        float sdCylinder(vec3 p, float h, float r) {
          vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
          return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
        }
        
        float ripples(float t) {
          return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
        }
        
        float hillTerrain(float t) {
          return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
        }
        
        vec3 getPath (vec3 startPos, vec3 endPos, float t){
          return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
        }
     
        float terrainVolumeSDF(vec3 p) {
          float h = terrainHeight(p.xz); // 2D hill over XZ
          return p.y - h;
        }

        float treeSDF(vec3 p) {
          p.z -= time;
          p =fract(p);
          // Distribute trees periodically over terrain
          vec2 cell = floor(p.xz * 2.0); // spacing
          vec3 pos = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
          pos.y -= terrainHeight(cell + 0.5); // offset by terrain

          float trunk = sdCylinder(pos,  0.5, .05); // trunk
          return trunk;
        }

        float foliageSDF(vec3 p, vec3 base, float rnd) {
          float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
          vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
          // vec3 q = fract(p)-0.5;
          return length(p - canopyCenter) - 0.15; // sphere canopy
        }

        float linearTerrainSDF(vec3 p) {
          // simulate terrain along X
          float h = fractalHill(p.y+(time*0.21)+ terrainVolumeSDF((p)));// Atlantic Deltas
            
          float r = ripples(h);
          h = fractalHill(p.y+(time*0.21)+ terrainVolumeSDF((p)));// Atlantic Deltas
          // float h = fractalHill(p.y+(time*0.1)+ treeSDF(fract(1.-p)));
          // h=r;
          return p.y - h; // above = positive, below = negative
        }

        float forestSDF(vec3 p) {
          float terrain = terrainVolumeSDF(p);
          float tree = treeSDF(p);
          float foliage = min(foliageSDF(p, (vec3(tree)), terrain), tree);
          // foliage = min(foliageSDF(p, -log(p), terrain), tree);
          // return min(min(terrain, tree), foliage);
          // return min(min(terrain, tree), foliage);
          return min((terrain, tree), foliage);
        }

        // Estimate normal from SDF
        vec3 computeNormal(vec3 p) {
          float d = terrainVolumeSDF(p)+forestSDF(p);
          vec2 e = vec2(0.001, 0.0);
          return normalize(vec3(
            terrainVolumeSDF(p + e.xyy) - d,
            terrainVolumeSDF(p + e.yxy) - d,
            terrainVolumeSDF(p + e.yyx) - d
          ));
        }
        
        vec3 terrainColor(vec3 p, float d) {
          // Shading
          vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
          if (d < MAX_DIST) {
            vec3 normal = computeNormal(p);
            float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
            color = vec3(0.3, 0.6, 0.2) * diff;
          } else {
            color = vec3(0.6, 0.8, 1.0); // sky
          }
            return color;
        }

        // Raymarching algorithm
        float renderer(vec3 ro, vec3 rd) {
          float t = 0.0;
          for (int i = 0; i < MAX_STEPS; i++) {
            vec3 p = ro + rd * t;
            float d = terrainVolumeSDF(p) + linearTerrainSDF(p);
            if (d < SURF_DIST || t > MAX_DIST) break;
            t += d;
          }
          return t;
        }
        
        vec4 raymarch(vec3 ro, vec3 rd) {
          float depthFactor = 0.064;
          float t = 0.0; // Total Distance Travelled By Ray
          vec3 depthGreyValue = vec3(t);
          vec3 p; // declared outside loop so it's accessible after 
          float ripple;
          float d = 0.0;
          vec3 path = getPath(ro, rd, t) ;
          
          for (int i = 0; i < 80; i++) {
            p = ro + rd * t;
            float d = terrainVolumeSDF(p)* linearTerrainSDF(p+path);// LandScape;
            d = terrainVolumeSDF(p)+ linearTerrainSDF(p+path);// Coniferous Forests
            // d = terrainVolumeSDF(p)* linearTerrainSDF(p+path)+hillTerrain(p.y); // Riparian Forest 
            d = forestSDF(p);
            d = treeSDF(p);
            d = getPath(ro, rd, p.x).y;
            d = linearTerrainSDF(p +path)+treeSDF(p); 
            // d+=forestSDF(p+path)+forestSDF(p)+linearTerrainSDF(p+path);
            // d = terrainVolumeSDF(p)+ linearTerrainSDF(p+path); //Snow Grassland
            // d = (terrainVolumeSDF(p)+ linearTerrainSDF(p+path)+hillTerrain(p.z)); // Plain Field
            if (d < 0.001 || t > 100.0) break;
        
            t += d;
            depthGreyValue = vec3(i) / 80.0;
          }
        
          float ray = t * 0.912 * depthFactor;
          ripple = ripples(ray*sin(time+0.7));
          
          // ðŸŒ¿ Base shading â€” default grass tint
          vec3 color = depthGreyValue * vec3(0.6, .85, 0.4);
          vec3 landScape = terrainColor(p, t);
          // color = depthGreyValue * landScape;
          // vec3 cloudyLandScape = terrainColor(p, t*ripple);
          // vec3 foggyLandScape = terrainColor(p, t/ripple);
          // color = depthGreyValue * landScape;
          // color = depthGreyValue / cloudyLandScape;// Wind AND 
          // color = depthGreyValue * foggyLandScape; // FloodedDelta
          // vec3 rayColor= rayPower(p, d, t);
        
          return vec4(color, ray);
        }
        
        float sdSun(vec2 u) {
          vec2 p = vec2(0.5)-u;
          return length(p)*2.0;
        }
        
        vec3 sunLight(vec2 uv) {
          float d = sdSun(uv);  // you can vary this radius
          float mask = 1.0 - smoothstep(0.0, 0.02, d);
          vec3 color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 0.9, 1.0), sin(time * 0.25) * 0.5 + 0.5);
          return color * mask;
        }
        
        vec3 dimensions(vec2 u) {
          vec2 pos = vec2(0.5)-u;
          vec3 p = vec3(pos, -9.0+time);
          float dx = distance(p.x, 0.0);
          float dy = distance(p.y, 0.0);
          float dz = distance(p.z, 0.0);
      
          float r = length(pos)*2.0; 
          float a = atan(pos.y,pos.x);
          float pzt = p.z*(time*0.00051);
            
          float tdy = dy*cos(0.3*atan(pzt, a)); 
            
          float ap = atan(p.y,atan(dx,tan(atan(a, atan(pzt, a)) )));
            a=ap-(p.z);
        
          float f = cos(a*5.1+(pzt));
          // f = abs(cos(a*3.));
          // f = abs(cos(a*2.5))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5; 		 
         float sh = 1.-smoothstep(f,f+0.02,r);
          return vec3(r, a, sh);
          }
      
        void main(){
          vec2 uv = gl_FragCoord.xy/resolution.xy;

          // Normalize Mouse normalized to same space (assuming it's passed in already as [0, res])
          vec2 mouse = (mousePosition * 2.0 - 1.0); // Convert to [-1, 1] range

          vec3 specs = dimensions(uv);
          float r = specs.x;
          float a = specs.y;
          float v = specs.z;
          float sun = sdSun(uv);
            
          // Camera setup
          vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
          vec3 lookAt = vec3(0.0, 0.0, 0.0);
          vec3 forward = normalize(lookAt - ro);
          vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
          vec3 up = cross(forward, right);
          vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);
            vec3 color;
        
          // March
          vec4 renderer = raymarch(ro, rd);
          // float d = renderer(ro, rd+time);
          // float dist = march.w;
          // vec3 p = ro + rd * dist;
        
        
          // vec3 color = vec3( 1.-smoothstep(f,f+0.02,r) );
          // color *= d;
          
          vec3 shape = r-vec3((v+renderer.w-r+v), renderer.y, a-renderer.z)-renderer.z/(sun);
          color = shape;
          // color = sunLight(uv); 

          float absT =  abs(sin(sineTime));
          // Check if hovered is active or not
          if (hovered > 0.0) {
            // Mouse is hovering, apply mouse interaction effects
            float dist = distance(mousePosition, uv);
            float absT =  abs(sin(sineTime));
            // dist +=  absT;
            
            // Use the distance to influence the color (make mouse position cause a color shift)
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Makes the area closer to the mouse lighter (for visible effect)

            // Use distance to control the opacity
            float opacity = smoothstep(0.0, 0.5, dist); // Opacity decreases with distance from the mouse position
            
            // Optionally, add sineTime-based animation for extra dynamics
            color *= 0.5 + (0.5) * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and time
                
            gl_FragColor = vec4(color, opacity);
          } else {
            // Mouse is not hovering, apply default effect based on UV coordinates and distance
            float dist = distance(uv, vec2(0.5, 0.5)); // Default base distance, could be replaced with your original calculation
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Use original UV-distance-bacoloring
            color = shape; // Sliding movement 
            color *= (0.1371)+ (0.975) * sin(time +( dist) * 10.0); // Add a dynamic oscillating effect based on distance and sineTime
            float opacity = smoothstep(0.6, 0.8, 1.0);
            gl_FragColor = vec4(color, opacity); // Default behavior
          }  
            color = shape; // Sliding movement
          gl_FragColor = vec4(color, 1.0);
        }
         
// void main(){
//     vec2 st = gl_FragCoord.xy/u_resolution.xy;
//     vec3 color = vec3(0.0);

//     vec2 pos = vec2(0.5)-st;

//     float r = length(pos)*2.0;
//     float a = atan(pos.y,pos.x);

//     float f = cos(a*3.);
//     // f = abs(cos(a*3.));
//     // f = abs(cos(a*2.5))*.5+.3;
//     // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
//     // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

//     color = vec3( 1.-smoothstep(f,f+0.02,r) );

//     gl_FragColor = vec4(color, 1.0);
// }







// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
float time = u_time;
vec2 mousePosition = u_mouse;
vec2 resolution = u_resolution.xy;

// Mystic Cave

        varying vec2 vUv;
        // uniform vec2 resolution;
        // uniform vec2 mousePosition;
        // uniform float time;
        uniform float hovered;
        uniform float sineTime;
        uniform float shapeFactor;
        uniform float explodeIntensity;

        #define MAX_STEPS 100
        #define MAX_DIST 100.0
        #define SURF_DIST 0.001
        vec3 dgv;
        
        // === Fractal Hill Pattern ===
        float fractalHill(float t) {
          float total = 0.0;
          float amplitude = 1.0;
          float frequency = 1.0;
          float persistence = 0.5;
        
          for (int i = 0; i < 4; i++) {
            total += sin(t * frequency * 3.14159) * amplitude;
            amplitude *= persistence;
            frequency *= 2.0;
          }
        
          return total * 0.5 + 0.5; // normalize to [0,1]
        }
        
        // Terrain height using XZ
        float terrainHeight(vec2 posXZ) {
          return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
        }
        
        // Usage
        float getHeight(float t) {
          return fractalHill(t); // fractal height
        }

        float sdCylinder(vec3 p, float h, float r) {
          vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
          return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
        }
        
        float ripples(float t) {
          return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
        }
        
        vec3 dimensions(vec2 u) {
          vec2 pos = vec2(0.5)-u;
          vec3 p = vec3(pos, -9.0+time);
          float dx = distance(p.x, 0.0);
          float dy = distance(p.y, 0.0);
          float dz = distance(p.z, 0.0);
      
          float r = length(pos)*2.0; 
          float pzt = p.z*(time*0.00051);
          float a = atan(pos.y,tan(p.z+fract(pos.x+p.z)));
            
          float tdy = dy*cos(0.3*atan(pzt, a)); 
            
          // float ap = atan(p.y,atan(dx,tan(atan(a, atan(pzt, a)) )));
          //   a=ap-(p.z);
        
          float f = cos(a*3.)*sin(a*3.);
          // f = abs(cos(a*3.));
          f = abs(cos(a*5.5))*.5+.3-r/2.;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1-r;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5; 		 
         float s = 1.-smoothstep(f,f+0.02,r);
          return vec3(r, a, s);
        }
        
        float hillTerrain(float t) {
          return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
        }
        
        vec3 getPath (vec3 startPos, vec3 endPos, float t){
          return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
        }
     
        float terrainVolumeSDF(vec3 p) {
          float h = terrainHeight(p.xz); // 2D hill over XZ
          return p.y - h;
        }

        float treeSDF(vec3 p) {
          p.z -= time;
          p =fract(p);
          // Distribute trees periodically over terrain
          vec2 cell = floor(p.xz * 2.0); // spacing
          vec3 pos = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
          pos.y -= terrainHeight(cell + 0.5); // offset by terrain

          float trunk = sdCylinder(pos,  0.5, .05); // trunk
          return trunk;
        }

        float foliageSDF(vec3 p, vec3 base, float rnd) {
          float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
          vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
          // vec3 q = fract(p)-0.5;
          return length(p - canopyCenter) - 0.15; // sphere canopy
        }

        float linearTerrainSDF(vec3 p) {
          // simulate terrain along X
          float h = fractalHill(p.y+(time*0.21)+ terrainVolumeSDF((p)));// Atlantic Deltas
            
          float r = ripples(h);
          h = fractalHill(p.y+(time*0.21)+ terrainVolumeSDF((p)));// Atlantic Deltas
          // float h = fractalHill(p.y+(time*0.1)+ treeSDF(fract(1.-p)));
          // h=r;
          return p.y - h; // above = positive, below = negative
        }

        float forestSDF(vec3 p) {
          float terrain = terrainVolumeSDF(p);
          float tree = treeSDF(p);
          float h = fractalHill(p.y+(time*0.21)+ terrainVolumeSDF((p)));// Atlantic Deltas
          float foliage = min(foliageSDF(p, (vec3(tree)), terrain), tree+h);
          // foliage = min(foliageSDF(p, -log(p), terrain), tree);
          return min((terrain, tree+h), foliage);
          // return min(min(terrain, tree), foliage);
          // return min((terrain, tree), foliage);
        }

        // Estimate normal from SDF
        vec3 computeNormal(vec3 p) {
          float d = terrainVolumeSDF(p)+forestSDF(p);
          vec2 e = vec2(0.001, 0.0);
          return normalize(vec3(
            terrainVolumeSDF(p + e.xyy) - d,
            terrainVolumeSDF(p + e.yxy) - d,
            terrainVolumeSDF(p + e.yyx) - d
          ));
        }
        
        vec3 terrainColor(vec3 p, float d) {
          // Shading
          vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
          if (d < MAX_DIST) {
            vec3 normal = computeNormal(p);
            float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
            color = vec3(0.3, 0.6, 0.2) * diff;
          } else {
            color = vec3(0.6, 0.8, 1.0); // sky
          }
            return color;
        }

        // Raymarching algorithm
        float renderer(vec3 ro, vec3 rd) {
          float t = 0.0;
          for (int i = 0; i < MAX_STEPS; i++) {
            vec3 p = ro + rd * t;
            float d = terrainVolumeSDF(p) + linearTerrainSDF(p);
            if (d < SURF_DIST || t > MAX_DIST) break;
            t += d;
          }
          return t;
        }
        
        vec4 raymarch(vec3 ro, vec3 rd) {
          float depthFactor = 0.064;
          float t = 0.0; // Total Distance Travelled By Ray
          vec3 depthGreyValue = vec3(t);
          vec3 p; // declared outside loop so it's accessible after 
          float ripple;
          float d = 0.0;
          vec3 path = getPath(ro, rd, t) ;
          
          for (int i = 0; i < 80; i++) {
            p = ro + rd * t;
            float d = terrainVolumeSDF(p)* linearTerrainSDF(p+path);// LandScape;
            d = terrainVolumeSDF(p)+ linearTerrainSDF(p+path);// Coniferous Forests
            // d = terrainVolumeSDF(p)* linearTerrainSDF(p+path)+hillTerrain(p.y); // Riparian Forest 
            // d = getPath(ro, rd, p.x).y;
            d += linearTerrainSDF(p +path)+treeSDF(p); 
            d = forestSDF(p);
            // d = treeSDF(p);
            // d/=forestSDF(p+path)+forestSDF(p)+linearTerrainSDF(p+path);// MillworkOceanBed
            d /= terrainVolumeSDF(p)+ linearTerrainSDF(p+path); //Snow Grassland
            // d /= (terrainVolumeSDF(p)+ linearTerrainSDF(p+path)+hillTerrain(p.z)); // Plain Field
            if (d < 0.001 || t > 100.0) break;
        
            t += d;
            depthGreyValue = vec3(i) / 80.0;
          }
        
          float ray = t * 0.912 * depthFactor;
          ripple = ripples(ray*sin(time+0.7));
          
          // ðŸŒ¿ Base shading â€” default grass tint
          vec3 color = depthGreyValue * vec3(0.6, .85, 0.4);
          vec3 landScape = terrainColor(p, t);
          // color = depthGreyValue * landScape;
          // vec3 cloudyLandScape = terrainColor(p, t*ripple);
          // vec3 foggyLandScape = terrainColor(p, t/ripple);
          // color = depthGreyValue * landScape;
          // color = depthGreyValue / cloudyLandScape;// Wind AND 
          // color = depthGreyValue * foggyLandScape; // FloodedDelta
          // vec3 rayColor= rayPower(p, d, t);
        
          return vec4(color, ray);
        }
        
        float sdSun(vec2 u) {
          vec2 p = vec2(0.5)-u;
          return length(p)*2.0;
        }
        
        vec3 sunLight(vec2 uv) {
          float d = sdSun(uv);  // you can vary this radius
          float mask = 1.0 - smoothstep(0.0, 0.02, d);
          vec3 color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 0.9, 1.0), sin(time * 0.25) * 0.5 + 0.5);
          return color * mask;
        }
        void main(){
          vec2 uv = gl_FragCoord.xy/resolution.xy;

          // Normalize Mouse normalized to same space (assuming it's passed in already as [0, res])
          vec2 mouse = (mousePosition * 2.0 - 1.0); // Convert to [-1, 1] range

          vec3 specs = dimensions(uv);
          float r = specs.x;
          float a = specs.y;
          float v = specs.z;
          float sun = sdSun(uv);
            
          // Camera setup
          vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
          vec3 lookAt = vec3(0.0, 0.0, 0.0);
          vec3 forward = normalize(lookAt - ro);
          vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
          vec3 up = cross(forward, right);
          vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);
            vec3 color;
        
          // March
          vec4 renderer = raymarch(ro, rd);
          // float d = renderer(ro, rd+time);
          // float dist = march.w;
          // vec3 p = ro + rd * dist;
        
        
          // vec3 color = vec3( 1.-smoothstep(f,f+0.02,r) );
          // color *= d;
          
          vec3 shape = r-vec3((renderer.w-r), renderer.y, renderer.z)-renderer.z/(sun);
          color = shape;
          // color = sunLight(uv); 

          float absT =  abs(sin(sineTime));
          // Check if hovered is active or not
          if (hovered > 0.0) {
            // Mouse is hovering, apply mouse interaction effects
            float dist = distance(mousePosition, uv);
            float absT =  abs(sin(sineTime));
            // dist +=  absT;
            
            // Use the distance to influence the color (make mouse position cause a color shift)
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Makes the area closer to the mouse lighter (for visible effect)

            // Use distance to control the opacity
            float opacity = smoothstep(0.0, 0.5, dist); // Opacity decreases with distance from the mouse position
            
            // Optionally, add sineTime-based animation for extra dynamics
            color *= 0.5 + (0.95) * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and time
                
            gl_FragColor = vec4(color, opacity);
          } else {
            // Mouse is not hovering, apply default effect based on UV coordinates and distance
            float dist = distance(uv, vec2(0.5, 0.5)); // Default base distance, could be replaced with your original calculation
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Use original UV-distance-bacoloring
            color = shape; // Sliding movement 
            color *= (0.1371+v/a)+ (0.975) * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and sineTime
            float opacity = smoothstep(0.6, 0.8, 1.0);
            gl_FragColor = vec4(color, opacity); // Default behavior
          }  
          // gl_FragColor = vec4(color, 1.0);
        }
         






/////// Fract Bumps// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
float time = u_time;
vec2 mousePosition = u_mouse;
vec2 resolution = u_resolution.xy;

// Mystic Cave

        varying vec2 vUv;
        // uniform vec2 resolution;
        // uniform vec2 mousePosition;
        // uniform float time;
        uniform float hovered;
        uniform float sineTime;
        uniform float shapeFactor;
        uniform float explodeIntensity;

        #define MAX_STEPS 100
        #define MAX_DIST 100.0
        #define SURF_DIST 0.001
   
        // === Fractal Hill Pattern ===
        float fractalHill(float t) {
          float total = 0.0;
          float amplitude = 1.0;
          float frequency = 1.0;
          float persistence = 0.5;
        
          for (int i = 0; i < 4; i++) {
            total += sin(t * frequency * 3.14159) * amplitude;
            amplitude *= persistence;
            frequency *= 2.0;
          }
        
          return total * 0.5 + 0.5; // normalize to [0,1]
        }
        
        // Terrain height using XZ
        float terrainHeight(vec2 posXZ) {
          return fractalHill(posXZ.x * 0.5 + sin(posXZ.y) * 0.25);
        }
        
        // Usage
        float getHeight(float t) {
          return fractalHill(t); // fractal height
        }

        float sdCylinder(vec3 p, float h, float r) {
          vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
          return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
        }
        
        float ripples(float t) {
          return 0.5 + 0.5 * sin(t * 2.0 * 3.14159); // repeats every 1.0
        }
        
        vec3 dimensions(vec2 u) {
          vec2 pos = vec2(0.5)-u;
          vec3 p = vec3(pos, -9.0+time);
          float dx = distance(p.x, 0.0);
          float dy = distance(p.y, 0.0);
          float dz = distance(p.z, 0.0);
      
          float r = length(pos)*2.0; 
          float pzt = p.z*(time*0.00051);
          float a = atan(pos.y,tan(p.z+fract(pos.x+p.z)));
            
          float tdy = dy*cos(0.3*atan(pzt, a)); 
            
          // float ap = atan(p.y,atan(dx,tan(atan(a, atan(pzt, a)) )));
          //   a=ap-(p.z);
        
          float f = cos(a*3.)*sin(a*3.);
          // f = abs(cos(a*3.));
          f = abs(cos(a*5.5))*.5+.3-r/2.;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1-r;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5; 		 
          float sh = 1.-smoothstep(f,f+0.02,r);
          return vec3(r, a, sh);
        }
        
        float hillTerrain(float t) {
          return abs(sin(t * 2.0 * 3.14159)); // double bump per cycle
        }
        
        vec3 getPath (vec3 startPos, vec3 endPos, float t){
          return mix(startPos, endPos, hillTerrain(t)); // rises, then falls
        }
     
        float terrainVolumeSDF(vec3 p) {
          float h = terrainHeight(p.xz); // 2D hill over XZ
          return p.y - h;
        }

        float foliageSDF(vec3 p, vec3 base, float rnd) {
          float foliageHeight = 0.2 + 0.1 * fract(rnd * 60.0);
          vec3 canopyCenter = base + vec3(0.0, foliageHeight, 0.0);
          // vec3 q = fract(p)-0.5;
          return length(p - canopyCenter) - 0.15; // sphere canopy
        }

        float treeSDF(vec3 p) {
          p.z -= time;
          p =fract(p);
          // Distribute trees periodically over terrain
          vec2 cell = floor(p.xz * 2.0); // spacing
          vec3 pos = p - vec3(cell.x + 0.5, 0.0 , cell.y + 0.5);
          pos.y -= terrainHeight(cell + 0.5); // offset by terrain
            

          float trunk = sdCylinder(pos,  0.5, .05)
*foliageSDF(p, -pos, .0); // trunk
            float foliage = foliageSDF(p, pos, 0.);
          return trunk;
          return min(trunk, foliage );
        }
        float linearTerrainSDF(vec3 p) {
          // simulate terrain along X
          float h = fractalHill(p.y+(time*0.21)+ terrainVolumeSDF((p)));// Atlantic Deltas
            
          float r = ripples(h);
          h = fractalHill(p.y+(time*0.21)+ terrainVolumeSDF((p)));// Atlantic Deltas
          // float h = fractalHill(p.y+(time*0.1)+ treeSDF(fract(1.-p)));
          // h=r;
          return p.y - h; // above = positive, below = negative
        }

        float forestSDF(vec3 p) {
          float terrain = terrainVolumeSDF(p);
          float tree = treeSDF(p);
          float h = fractalHill(p.y+(time*0.21)+ terrainVolumeSDF((p)));// Atlantic Deltas
          float foliage = min(foliageSDF(p, (vec3(tree)), terrain), tree+h);
          // foliage = min(foliageSDF(p, -log(p), terrain), tree);
          return min((terrain, tree+h), foliage);
          // return min(min(terrain, tree), foliage);
          // return min((terrain, tree), foliage);
        }

        // Estimate normal from SDF
        vec3 computeNormal(vec3 p) {
          float d = terrainVolumeSDF(p)+forestSDF(p);
          vec2 e = vec2(0.001, 0.0);
          return normalize(vec3(
            terrainVolumeSDF(p + e.xyy) - d,
            terrainVolumeSDF(p + e.yxy) - d,
            terrainVolumeSDF(p + e.yyx) - d
          ));
        }
        
        vec3 terrainColor(vec3 p, float d) {
          // Shading
          vec3 color = vec3(0.6, 0.85, 0.4); // default grass color
          if (d < MAX_DIST) {
            vec3 normal = computeNormal(p);
            float diff = clamp(dot(normal, vec3(0.3, 1.0, 0.5)), 0.0, 1.0);
            color = vec3(0.3, 0.6, 0.2) * diff;
          } else {
            color = vec3(0.6, 0.8, 1.0); // sky
          }
            return color;
        }

        // Raymarching algorithm
        float renderer(vec3 ro, vec3 rd) {
          float t = 0.0;
          for (int i = 0; i < MAX_STEPS; i++) {
            vec3 p = ro + rd * t;
            float d = terrainVolumeSDF(p) + linearTerrainSDF(p);
            if (d < SURF_DIST || t > MAX_DIST) break;
            t += d;
          }
          return t;
        }
        
        vec4 raymarch(vec3 ro, vec3 rd) {
          float depthFactor = 0.064;
          float t = 0.0; // Total Distance Travelled By Ray
          vec3 depthGreyValue = vec3(t);
          vec3 p; // declared outside loop so it's accessible after 
          float ripple;
          float d = 0.0;
          vec3 path = getPath(ro, rd, t) ;
          
          for (int i = 0; i < 80; i++) {
            p = ro + rd * t;
            float d = terrainVolumeSDF(p)* linearTerrainSDF(p+path);// LandScape;
            d = terrainVolumeSDF(p)+ linearTerrainSDF(p+path);// Coniferous Forests
            // d = terrainVolumeSDF(p)* linearTerrainSDF(p+path)+hillTerrain(p.y); // Riparian Forest 
            // d = getPath(ro, rd, p.x).y;
            d = linearTerrainSDF(p +path)+treeSDF(p); 
            d = forestSDF(p);
            d = treeSDF(p);
            // d+=forestSDF(p+path)+forestSDF(p)+linearTerrainSDF(p+path);
            // d = terrainVolumeSDF(p)+ linearTerrainSDF(p+path); //Snow Grassland
            // d = (terrainVolumeSDF(p)+ linearTerrainSDF(p+path)+hillTerrain(p.z)); // Plain Field
  
            if (d < 0.001 || t > 100.0) break;
        
            t += d;

            depthGreyValue = vec3(i) / 80.0;
          }
        
          float ray = t * 0.912 * depthFactor;
          ripple = ripples(ray*sin(time+0.7));
          
          // ðŸŒ¿ Base shading â€” default grass tint
          vec3 color = depthGreyValue * vec3(0.6, .85, 0.4);
          vec3 landScape = terrainColor(p, t);
          // color = depthGreyValue * landScape;
          // vec3 cloudyLandScape = terrainColor(p, t*ripple);
          // vec3 foggyLandScape = terrainColor(p, t/ripple);
          // color = depthGreyValue * landScape;
          // color = depthGreyValue / cloudyLandScape;// Wind AND 
          // color = depthGreyValue * foggyLandScape; // FloodedDelta
          // vec3 rayColor= rayPower(p, d, t);
        
          return vec4(color, ray);
        }
        
        float sdSun(vec2 u) {
          vec2 p = vec2(0.5)-u;
          return length(p)*2.0;
        }
        
        vec3 sunLight(vec2 uv) {
          float d = sdSun(uv);  // you can vary this radius
          float mask = 1.0 - smoothstep(0.0, 0.02, d);
          vec3 color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 0.9, 1.0), sin(time * 0.25) * 0.5 + 0.5);
          return color * mask;
        }
        void main(){
          vec2 uv = gl_FragCoord.xy/resolution.xy;

          // Normalize Mouse normalized to same space (assuming it's passed in already as [0, res])
          vec2 mouse = (mousePosition * 2.0 - 1.0); // Convert to [-1, 1] range

          vec3 specs = dimensions(uv);
          float r = specs.x;
          float a = specs.y;
          float v = specs.z;
          float sun = sdSun(uv);
            
          // Camera setup
          vec3 ro = vec3(0.0, 1.0, -3.5); // camera origin
          vec3 lookAt = vec3(0.0, 0.0, 0.0);
          vec3 forward = normalize(lookAt - ro);
          vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
          vec3 up = cross(forward, right);
          vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);
          vec3 color;
        
          // March
          vec4 renderer = raymarch(ro, rd);
          // float d = renderer(ro, rd+time);
          // float dist = march.w;
          // vec3 p = ro + rd * dist;
        
        
          // vec3 color = vec3( 1.-smoothstep(f,f+0.02,r) );
          // color *= d;
          
          vec3 shape = r-vec3((renderer.w-r), renderer.y, renderer.z)-renderer.z/(sun);
          color = shape;
          // color = sunLight(uv); 

          float absT =  abs(sin(sineTime));
          // Check if hovered is active or not
          if (hovered > 0.0) {
            // Mouse is hovering, apply mouse interaction effects
            float dist = distance(mousePosition, uv);
            float absT =  abs(sin(sineTime));
            // dist +=  absT;
            
            // Use the distance to influence the color (make mouse position cause a color shift)
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Makes the area closer to the mouse lighter (for visible effect)

            // Use distance to control the opacity
            float opacity = smoothstep(0.0, 0.5, dist); // Opacity decreases with distance from the mouse position
            
            // Optionally, add sineTime-based animation for extra dynamics
            color *= 0.5 + (0.95) * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and time
                
            gl_FragColor = vec4(color, opacity);
          } else {
            // Mouse is not hovering, apply default effect based on UV coordinates and distance
            float dist = distance(uv, vec2(0.5, 0.5)); // Default base distance, could be replaced with your original calculation
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Use original UV-distance-bacoloring
            color = shape; // Sliding movement 
            color *= (0.1371+v/a)+ (0.975) * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and sineTime
            float opacity = smoothstep(0.6, 0.8, 1.0);
            gl_FragColor = vec4(color, opacity); // Default behavior
          }  
          // gl_FragColor = vec4(color, 1.0);
        }

// void main(){
//     vec2 st = gl_FragCoord.xy/u_resolution.xy;
//     vec3 color = vec3(0.0);

//     vec2 pos = vec2(0.5)-st;

//     float r = length(pos)*2.0;
//     float a = atan(pos.y,pos.x);

//     float f = cos(a*3.);
//     // f = abs(cos(a*3.));
//     // f = abs(cos(a*2.5))*.5+.3;
//     // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
//     // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

//     color = vec3( 1.-smoothstep(f,f+0.02,r) );

//     gl_FragColor = vec4(color, 1.0);
// }

