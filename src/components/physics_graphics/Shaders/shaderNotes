
  useWiredCityTerrainSDFShader() {
    this.wiredCityTerrainSDFShader = {
      uniforms: {
        resolution: { value: new THREE.Vector2(this.width, this.height) },
        time: { value: this.time },
        hovered: { value: this.hovered },
        shapeFactor: { value: this.shapeFactor },
        explodeIntensity: { value: this.explodeIntensity },
        mousePosition: { value: new THREE.Vector2(0.0, 0.0) },
      },

      vertexShader: `
        uniform float time;
        uniform float hovered;
        uniform vec2 mousePosition;
        uniform float explodeIntensity;
        varying vec2 vUv;
  
        float noise(vec2 p) {
          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }
  
        void main() {
          vUv = uv;
          vec3 pos = position;
      
          // Calculate distance to mouse position
          float dist = distance(mousePosition, vec2(pos.x, pos.y));
          float effect = hovered * smoothstep(0.2, 0.0, dist) * noise(pos.xy * 10.0 + time);
      
          // Apply explode effect
          pos += normal * effect * explodeIntensity;
      
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,

      fragmentShader: `
        varying vec2 vUv;
        uniform vec2 resolution;
        uniform vec2 mousePosition;
        uniform float time;
        uniform float hovered;
        uniform float shapeFactor;
        uniform float explodeIntensity;
  
        // Cyclic noise function with smooth oscillations
        float cyclicNoise(vec2 p) {
          float angle = sin(p.x * 5.0 + time * 0.5) + cos(p.y * 5.0 + time * 0.5);
          return fract(sin(dot(p + angle, vec2(12.9898, 78.233))) * 43758.5453);
        }
  
        // Noise function (similar to saw shader)
        float abstractNoise(vec2 p) {
          float angle = sin(p.x * 5.0 + time * 0.5) + cos(p.y * 5.0 + time * 0.5);
          return fract(sin(dot(p + angle, vec2(12.9898, 78.233))) * 43758.5453);
        }
  
        // Smoothstep interpolation function for blending
        float S(float t) {
          return t * t * (3.0 - 2.0 * t);
        }
  
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
        }
  
        float harshNoise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
  
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), u.x),
                    mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), u.x), u.y);
        }
  
        // Smooth noise based on UV coordinates
        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          
          vec2 u = f * f * (3.0 - 2.0 * f);
          
          return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
  
        float opUnion(float d1, float d2) {
          return min(d2, d2);
        }
  
        float opSubtraction(float d1, float d2) {
          return max(-d1, d2);
        }
  
        float opIntersection(float d1, float d2) {
          return max(d1, d2);
        }
  
        float opSmoothUnion(float d1, float d2, float k) {
          float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
          return mix(d2, d1, h) - k * h * (1.0 - h);
        }
  
        float opSmoothSubtraction(float d1, float d2, float k) {
          float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
          return mix(d2, -d1, h) + k * h * (1.0 - h);
        }
  
        float opSmoothIntersection(float d1, float d2, float k) {
          float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
          return mix(d2, -d1, h) + k * h * (1.0 - h);
        }
  
        float smin(float a, float b, float k) {
          float h = max(k - abs(a - b), 0.0) / k;
          return min(a, b) - h * h * h * k * (1.0 / 6.0);
        }
  
        float dist(vec3 p) {
          return length(p) - 1.0;
        }

        mat2 rot2D(float angle) {
          float s = sin(angle);
          float c = cos(angle);
  
          return mat2(c, -s, s, c);
        }
  
        vec3 rot3D(vec3 p, vec3 axis, float angle) {
          // Rodrigues' Rotation Formula
          return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);
        }
  
        float sdSphere(vec3 p, float r) {
          return length(p) - r;
        }
  
        // Create a basic box (building) SDF
        float sdBox(vec3 p, vec3 l) {
          vec3 q = abs(p) - l; 
          return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
        }

        // Create a cuboid box (building) SDF
        float sdBuilding(vec3 p, vec3 size) {
          vec3 d = abs(p) - size;  // Get the distance from the cuboid
          return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
        }

        float sdGround(vec3 p) {
          return p.y + 0.75; // Ground SDF
        }

        // Signed distance function for a cone
        float sdCone(vec3 p, vec3 dir, float height, float radius) {
            // Ensure direction is normalized
            dir = normalize(dir);

            // Project point onto the cone's axis
            float d = dot(p, dir);
            vec3 projected = dir * d;

            // Compute the distance from the projected point to the actual point
            float lateralDist = length(p - projected);
            
            // Compute the expected radius at this height
            float expectedRadius = (d / height) * radius;

            // Compute the signed distance (negative inside, positive outside)
            float distance = lateralDist - expectedRadius;

            // Enforce height limits
            float capBottom = d;
            float capTop = d - height;
            
            // If above the cone's tip or below the base, clamp distance
            return max(distance, max(-capBottom, capTop));
        }

        // Bird body (simplified)
        float sdBirdBody(vec3 p, float size) {
            return sdSphere(p, size);
        }

        // Simplified Bird wings (simplified with two spheres for each wing)
        float sdWing(vec3 p, vec3 wingPos, vec3 birdPos, float wingSize, float angle) {
            // Rotate the wing around the body for animation
            // vec3 rotatedPos = rot3D(p - wingPos, vec3(0.0, 0.0, 1.0), angle) + wingPos;
            vec3 rotatedPos = rot3D(p - wingPos, birdPos, angle) + wingPos;
            return sdSphere(rotatedPos, wingSize); // Using sphere to approximate wing
        }

        // Bird head
        float sdHead(vec3 p, vec3 headPos, float headSize) {
            return sdSphere(p - headPos, headSize);
        }

        // Bird beak
        float sdBeak(vec3 p, vec3 headPos, float beakLength) {
            vec3 beakDir = normalize(p - headPos);
            return sdCone(p - headPos, beakDir, beakLength, 0.1); // A cone for the beak
        }

        // Combine the components to form a bird
        float sdBird(vec3 p, vec3 bodyPos, float bodySize, vec3 wingPos, float wingSize, vec3 headPos, float headSize, float beakLength, float wingAngle) {
            float body = sdBirdBody(p - bodyPos, bodySize);
            float wing1 = sdWing(p, wingPos, wingSize, wingAngle);
            float wing2 = sdWing(p, wingPos + vec3(0.5, 0.0, 0.0), wingSize, -wingAngle); // Second wing
            float head = sdHead(p, headPos, headSize);
            float beak = sdBeak(p, headPos, beakLength);
            // Combine parts using smooth union
            return opSmoothUnion(opSmoothUnion(body, wing1, 0.1), opSmoothUnion(wing2, opSmoothUnion(head, beak, 0.1), 0.1), 0.1);
        }

        // Main Map with birds in the scene
        float map(vec3 p) {
          // Sun
          vec3 sunPos = vec3(sin(time) * 3.0, 9.0, -90.0); // Sun Position
          float sun = sdSphere(p - sphPos, 1.0); // Sphere SDF

          // Bird position and movement based on time
          vec3 birdPos = vec3(sin(time) * 3.0, cos(time) * 3.0, time); // Bird movement
          float bodySize = 0.5;
          float wingSize = 0.2;
          float headSize = 0.2;
          float beakLength = 0.1;
          float wingAngle = sin(time * 2.0) * 0.5; // Flapping wing animation

          // Age Factor
          float ageFactor = 0.5 + 0.3 * sin(time * 2.0);  // Dynamic size variation
  
          vec3 q = p; // input copy

          // Weather Factor
          q.z += time * 0.4; // Forward Camera Movement    

          // the ommitted swizzled vec param is the axis of rotation
          // q.xz = fract(p.xz) - 0.5; // Space Repetition 0.5 is the center of repetition
          // q.y -= time * 0.4; // Upward Movement
  
          // float box = sdBox(q * 3.0, vec3(0.15)) / 3.0; 
          q = fract(p) - 0.5; // Space Repetition 0.5 is the center of repetition
          q.xz *= rot2D(time * 0.4);
          // fluid lines float box = sdBox(q * 3.0, vec3(0.15) * 3.0) / 3.0; // Scaled Cube SDF

          // Calculate building's position based on street number
          float buildingHeight = 3.0 + noise(q.xz * 0.1) * 2.0; // Random building height
          vec3 buildingPos = q - vec3(mod(q.x, grid_size), 0.0, mod(q.z, grid_size));
          float building = sdBuilding(buildingPos * 3.0, vec3(boxSize, buildingHeight, boxSize * 3.0) / 3.0) / 3.0;  // Generate a unique "houseNumber" based on the building's grid position

          // Use hash function to introduce randomness for building properties based on the houseNumber
          float houseNumber = floor(buildingPos.x / grid_size) + floor(buildingPos.z / grid_size) * 57.0;  // Unique ID for each building
          float heightFactor = hash(houseNumber + 1.0); // Random value for height variation
          float sizeFactor = hash(houseNumber + 2.0);   // Random value for size variation

          // Apply these random values to alter building height and size
          buildingHeight += heightFactor * 2.0; // Alter height based on houseNumber
          boxSize += sizeFactor * 0.5;          // Alter size based on houseNumber

          // Generate birds
          float bird = sdBird(q, birdPos, bodySize, birdPos, wingSize, birdPos + vec3(0.0, 0.5, 0.0), headSize, beakLength, wingAngle);
          
          // Smaller birds at different offsets// Young birds (light, fly higher, move faster)
          float youngHeight = mix(4.0, 2.0, ageFactor);  
          float youngVelocity = mix(2.0, 1.2, ageFactor);
          float youngBirds = sdBird(q, birdPos + vec3(2.0, youngHeight, -1.0), 
                                    bodySize * ageFactor, 
                                    birdPos, wingSize * ageFactor, 
                                    birdPos + vec3(0.0, 0.5, 0.0) * ageFactor, 
                                    headSize * ageFactor, beakLength * ageFactor, wingAngle);

          // Mature birds (medium weight, moderate altitude and speed)
          float matureHeight = mix(3.5, 1.5, ageFactor * 0.8);
          float matureVelocity = mix(1.5, 0.8, ageFactor * 0.8);
          float matureBirds = sdBird(q, birdPos + vec3(2.0, matureHeight, -1.0), 
                                    bodySize * ageFactor * 0.5, 
                                    birdPos, wingSize * ageFactor, 
                                    birdPos + vec3(0.0, 0.5, 0.0) * ageFactor, 
                                    headSize * ageFactor, beakLength * ageFactor, wingAngle);

          // Aged birds (heavier, fly lower, move slower)
          float agedHeight = mix(2.5, 1.0, ageFactor * 0.6);
          float agedVelocity = mix(1.0, 0.5, ageFactor * 0.6);
          float agedBirds = sdBird(q, birdPos + vec3(-3.0, agedHeight, 2.5), 
                                  bodySize * (ageFactor * 0.8), 
                                  birdPos, wingSize * (ageFactor * 0.8), 
                                  birdPos + vec3(0.0, 0.5, 0.0) * (ageFactor * 0.8), 
                                  headSize * (ageFactor * 0.8), beakLength * (ageFactor * 0.8), wingAngle);

          // Combine the ground with buildings
          float terrain = min(ground, building); 
          float terrainBirds = opSmoothIntersection(terrain, min(bird, flock), min(bird, terrain)); 
  
          // To combine the two shapes using the union operator
          //return smin(sphere, box, 2.0); // The additional param is for the blending
          // return smin(ground, box, 2.0); // The additional param is for the blending
          // return opSmoothIntersection(ground, smin(box, sun, min(box, sun)), 2.0); /// Returned image
          return opSmoothUnion(terrain, opSmoothUnion(building, terrainBirds, opSmoothUnion(bird, flock, terrainBirds)), min(flock, terrain));
        }

        vec3 computeNormal(vec3 p) {
          float epsilon = 0.001;
          return normalize(vec3(
              map(p + vec3(epsilon, 0, 0)) - map(p - vec3(epsilon, 0, 0)),
              map(p + vec3(0, epsilon, 0)) - map(p - vec3(0, epsilon, 0)),
              map(p + vec3(0, 0, epsilon)) - map(p - vec3(0, 0, epsilon))
          ));
        }

        // Function to compute soft shadows
        float computeSoftShadow(vec3 p, vec3 lightPos) {
          vec3 shadowDir = normalize(lightPos - p);
          float shadowT = 0.1; // Small initial offset to avoid self-shadowing
          float shadowFactor = 1.0;
          float maxDist = 5.0;

          for (int j = 0; j < 24; j++) { // Optimized loop count
            vec3 shadowPoint = p + shadowDir * shadowT;
            float shadowDist = map(shadowPoint);
                
            if (shadowDist < 0.001) {
              shadowFactor *= 0.5; // Reduce intensity for occlusion
            }
                
            shadowT += shadowDist * 0.5; // Smaller steps improve softness
            if (shadowT > maxDist) break; // Stop marching if too far
          }

          return clamp(shadowFactor, 0.2, 1.0); // Ensure valid shadow range
        }
      
        vec3 computeCameraPosition(float time) {
          float radius = 5.0; // Adjust for larger or smaller movement
          float speed = 0.5; // Adjust rotation speed
      
          float camX = radius * cos(time * speed);
          float camZ = radius * sin(time * speed);
          
          return vec3(camX, 1.5, camZ - 3.0); // Y-position can be adjusted for height
        }

        vec3 applyFog(vec3 color, float distance, vec3 fogColor, float fogDensity) {
          float fogFactor = exp(-distance * fogDensity); // Exponential fog
          return mix(fogColor, color, fogFactor); // Blend fog with scene color
        }

        void wiggleCamera(inout vec3 ro, inout vec3 rd, vec2 uv, vec2 mouse, float time) {
          // Adding wiggle effect to the camera
          ro.x += sin(time * 2.0) * 0.5;
          ro.y += cos(time * 1.5) * 0.2;
          
          // Slight noise-based distortion on ray direction
          rd += normalize(vec3(
              sin(uv.x * time * 0.5) * 0.1,  
              cos(uv.y * time * 0.3) * 0.1,  
              sin(uv.x * time * 0.7) * 0.1  
          ));

          rd = normalize(rd); // Normalize direction after adding noise

          // Camera rotations
          ro.xz *= rot2D(-mouse.x);
          rd.xz *= rot2D(-mouse.x);
      
          ro.yz *= rot2D(-mouse.y);
          rd.yz *= rot2D(-mouse.y);
        }
        
        // Main fragment shader function
        void main() {
            vec2 fragCoord = gl_FragCoord.xy;
            vec2 uv = fragCoord / resolution; // Proper UV mapping
            vec2 mouse = (mousePosition.xy * 2.0 - fragCoord) / resolution.y;

            // Noise and Soft Min calculations
            float n = noise(uv * sin(shapeFactor + uv.x) + sin(uv * sin(shapeFactor + uv.x)));
            float smn = smin(uv.x + time, uv.y + shapeFactor, shapeFactor + sin(uv.x * shapeFactor));
            float shadowIntensity = 0.1;
        
            // UV Transformations
            uv *= 2.0 + time;
        
            float fov = 1.0;
            vec3 ro = vec3(0, 0, -3); // Ray Origin
            vec3 rd = normalize(vec3(uv * fov, 1)); // Ray Direction
        
            uv *= 1.2 + noise(uv * time) * 0.05;  // Slight noise-based distortion

            // Shadow and Reflections
            vec3 lightPos = vec3(0.0, 10.0, -5.0); // Light position
            vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0)); // Camera view direction
            vec3 lightDir;

            // Apply wiggle effect to the camera
            wiggleCamera(ro, rd, uv, mouse, time);
        
            // ðŸ”¥ðŸ”¥ Ray Marching Algorithm
            float depthFactor = 0.064;
            float lightIntensity = 0.02;
            float t = 0.0; // Total Distance Travelled By Ray
            vec3 normal; // Declare normal
            //vec3 color = vec3(t);
            vec3 color = vec3(t * time * 0.2 * depthFactor + noise(uv.xy * 3.0 + time * 0.5));
        
            // Ray Marching Algorithm
            for (int i = 0; i < 80; i++) {
                vec3 p = ro + rd * t; // Position along the ray
                float d = map(p); // Current distance to the scene
                lightDir = normalize(lightPos - p);
                    
                // Compute Shadows and reflections
                if (d < 0.001) {  
                  normal = computeNormal(p); // âœ… Compute surface normal here vec3 p, vec3 lightPos
                  float shadow = computeSoftShadow(p + normal * 0.02, lightPos);
                  //float light = computeLighting(p, normal, lightPos, viewDir, shadow);
                  shadowIntensity = computeSoftShadow(p, lightPos); // Call function
                  // shadowIntensity = computeSoftShadow(p, lightPos); // Compute soft shadow
                  // shadowIntensity = computeHardShadow(p, lightPos); // Call function
                  // color *= shadowIntensity; // Apply shadow effect
                  break;
        
                t += d; // March the distance
        
                color = vec3(i) / 80.0;
        
                if (d < 0.001 || t > 100.0) break;
            
            }
            // Apply depth factor
            float rayPower = t * 0.003 * lightIntensity * depthFactor * shadowIntensity;
  
            // Define fog parameters
            vec3 fog = vec3(0.2, 0.3, 0.4); // Adjust for desired atmosphere
            float fogDensity = 0.02; // Adjust for stronger/weaker fog
  
            // Final Coloring with Shadows
            float rgR = rayPower + S(noise(uv.xy * 4.0 + time * 0.3)) + shadowIntensity;
            float rgG = rayPower + S(noise(uv.yx * 3.0 + time * 0.5)) + shadowIntensity;
            float rgB = rayPower + S(noise(uv.xy * 2.0 + time * 0.7)) + shadowIntensity;
            
            color = vec3(rgR, rgG, rgB);
  
            color = applyFog(color, t, fog, fogDensity);
            //color = mix(color, fog, 1.0 - exp(-fogDensity * t));
  
          
            gl_FragColor = vec4(color, 1);
          }
        }        
      `
    };

    this.wiredCityTerrainSDFMaterial = new THREE.ShaderMaterial(this.wiredCityTerrainSDFShader);    
  }  
void main(){
    vec2 uv = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    vec2 pos = vec2(0.550,0.540)-uv;

    float r = length(pos)*2.616;
    float a = fract(atan(pos.y,fract(pos.x) - 0.2)) - r;

    float f = cos(a*fract(11.472) - 0.708);
    f = abs(cos(a*3.));
    f = abs(cos(a*2.5))*.5+.3;
    f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

    color = vec3( 1.-smoothstep(f,sin(f + r)+-0.268,r) );

    gl_FragColor = vec4(color, 1.0);
}uniform float time;

float box(in vec2 u, in vec2 _size){
    _size = vec2(0.5) - _size*0.5;
    vec2 uv = smoothstep(_size,
                        _size+vec2(0.001),
                        u);
    uv *= smoothstep(_size,
                    _size+vec2(0.001),
                    vec2(1.0)-u);
    return uv.x*uv.y;
}

float cross(in vec2 u, float _size){
    return  box(u, vec2(_size,_size/4.)) +
            box(u, vec2(_size/4.,_size));
}

void main(){
    vec2 uv = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    // To move the cross we move the space
    vec2 translate = vec2(cos(time),sin(time));
    uv += translate*0.35;

    // Show the coordinates of the space on the background
    // color = vec3(uv.x,uv.y,0.0);

    // Add the shape on the foreground
    color += vec3(cross(uv,0.25));

    gl_FragColor = vec4(color,1.0);
}

mat2 scale(vec2 _scale){
    return mat2(_scale.x,0.0,
                0.0,_scale.y);
}
mat2 scale(vec2 _scale){
    return mat2(_scale.x,0.0,
                0.0,_scale.y);
}

float rollinBox(in vec2 u, in vec2 s){
  s = vec2(0.5) - s*0.5;
  vec2 suv = smoothstep(
    s,
    s+vec2(0.001),
    u
  );
  suv *= smoothstep(
    s,
    s+vec2(0.001),
    vec2(1.0)-u
  );
  return suv.x*suv.y;
}

float sdDragonShape(vec3 p) {
    // Trunk Calculation
    float r = length(p) * 2.616;
    float a = fract(atan(p.y, fract(p.x) - 0.2)) - r;

    // Legs and Shape Calculation
    float f = cos(a * fract(11.472) - 0.708);
    f = abs(cos(a * 3.));
    f = abs(cos(a * 2.5)) * 0.5 + 0.3;
    f = abs(cos(a * 12.) * sin(a * 3.)) * 0.8 + 0.1;
    f = smoothstep(-0.5, 1.0, cos(a * 10.)) * 0.2 + 0.5;

    // Return distance to the surface of the dragon
    return smoothstep(f, sin(f + r) - 0.268, r);
}

float dragonSpider(vec2 p) {
    // vec2 pos = vec2(0.550,0.540)-uv;

    // trunk
    float r = length(p)*2.616;
    float a = fract(atan(p.y,fract(p.x) - 0.2)) - r;

    // Legs
    float f = cos(a*fract(11.472) - 0.708);
    f = abs(cos(a*3.));
    f = abs(cos(a*2.5))*.5+.3;
    f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

    vec3 color = vec3( 1.-smoothstep(f, sin(f + r)+-0.268,r) );
    return color;
}

float cross(in vec2 u, float s){
    return  box(u, vec2(s,s/4.)) +
            box(u, vec2(s/4.,s));
}

void main(){
    vec2 uv = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    uv -= vec2(0.5);
    uv = scale( vec2(sin(time)+1.0) ) * uv;
    uv += vec2(0.5);

    // Show the coordinates of the space on the background
    // color = vec3(uv.x,uv.y,0.0);

    // Add the shape on the foreground
    color += vec3(cross(uv,0.2));

    gl_FragColor = vec4(color,1.0);
}


        
        // Translucent rain drop SDF, which changes with time
        float rainDrop(vec3 p, float dropRadius, float velocityFactor, float fogFactor) {
          // Movement along y-axis (simulating falling rain)
          p.y -= time * velocityFactor;  // Adjust for y-axis movement
            
           // Simple spherical drop SDF (a radius around the position)
          float dist = length(p) - dropRadius;
            
          // Simulate translucency (falloff based on distance and fog)
          float trans = smoothstep(0.0, 1.0, dist * fogFactor);  // Increase fogFactor for denser fog
            
          // Fractal noise to randomize the rain's fall and movement
          float rainNoise = fractalNoise(p) * 0.1;
            
          // Apply a visual shift (translucent effect + rain noise)
          return trans * max(0.0, dist + rainNoise);
        }
        
        // Translucent rain drop SDF, which changes with time
        // float rainDrop(vec3 p, float dropRadius, float velocityFactor, float fogFactor) {
        //   // Movement along y-axis (simulating falling rain)
        //   p.y -= time * velocityFactor;  // Adjust for y-axis movement
            
        //   // Simple spherical drop SDF (a radius around the position)
        //   float dist = length(p) - dropRadius;
            
        //   // Simulate translucency (falloff based on distance and fog)
        //   float trans = smoothstep(0.0, 1.0, dist * fogFactor);  // Increase fogFactor for denser fog
            
        //   // Fractal noise to randomize the rain's fall and movement
        //   float rainNoise = fractalNoise(p) * 0.1;
            
        //   // Apply a visual shift (translucent effect + rain noise)
        //   return trans * max(0.0, dist + rainNoise);
        // }

        // Function to check if two rain drops are close enough to merge
        float mergeRainDrops(vec3 p1, vec3 p2, float mergeDistance) {
            return smoothstep(0.0, mergeDistance, length(p1 - p2));  // Return 1 if within merge distance
        }
        
        // Main map function that integrates rain and fog
        vec3 getRainEffect(vec3 p, vec3 uv, float t, float vf, float shadowStrength, vec3 normal, vec3 viewDir, float fg) {
          // Rain drop parameters
          float dropRadius = 0.05; // Size of a single drop
          float velocityFactor = smoothstep(vf, vf * 0.2, vf + sin(pow(vf, time))); // Falling speed of the rain drop
          float fogFactor = fg * (smoothstep(0.0, 1.0, t * time * 0.2)); // Simulate increasing fog over time
          vec3 rainPosition = vec3(fractalNoise(p.xz * 0.1), p.y, fractalNoise(p.xz * 0.1) * 0.5);
            
          // Generate a grid of drops or randomize positions (add fractal for natural distribution)
          vec3 rainPosition = vec3(fractalNoise(p.xz * 0.1), p.y, fractalNoise(p.xz * 0.1) * 0.5);
            
          // Create rain drop SDF
          float drop = rainDrop(p - rainPosition, dropRadius, velocityFactor, fogFactor);
            
          // Check if rain drops are close enough to merge and make larger drops
          // This could involve checking the proximity of multiple drops (simple example with two)
          float merge = mergeRainDrops(p, rainPosition, dropRadius * 2.0); // Adjust merge distance as needed
            
          // Final color adjustment: mix the rain with fog and lighting
          vec3 rainColor = vec3(0.5, 0.5, 0.8) * (1.0 - fogFactor); // A bluish rain color
          vec3 finalColor = mix(rainColor, vec3(0.7, 0.7, 0.7), merge);  // Merge with fog factor and visual shift
        
          return finalColor;
        }

        // The main map function that will define the scene
        float mapTerrain(vec3 p) {
          // Define building parameters
          vec3 spherePos = vec3(-5.0 * sin(time * 5.0), 2.0, 0.0);
          // spherePos += rotate3D(spherePos, vec3(1.0, 0.5, 0.0), time * 0.3);
          float sphere = sdSphere(p - spherePos, 0.9);

          // Ground SDF
          float ground = sdGround(p);
          // p += rot3D(p, p.xy, angle);  
  
          // Infinite city generation
          vec3 q = p; // input copy

          // Weather Factor the ommitted swizzled vec param is the axis of rotation
          q.z += time * 0.4; // Forward Camera Movement  
          q.y -= time * 0.4; // Upward Movement

          // q.xz *= rot2D(time * 0.4);
          q = fract(p) - 0.5; // Space Repetition 0.5 is the center of repetition
          //q.xz = fract(p.xz) - 0.5; // Space Repetition 0.5 is the center of repetition

          // // Boxes
          float boxSize = 1.0;
          float box = sdBox(q * 4.0, vec3(0.25)) / 4.0;

          // Streets and Parkways, Create building SDF and place it on street
          // Use mod(p.x, grid_size) and mod(p.z, grid_size) for infinite grid layout
          float grid_size = 15.0;  // Grid spacing for streets & buildings
          float road_width = 2.5;  // Adjust road width

          // Calculate building's position based on street number
          float buildingHeight = 3.0 + noise(p.xz * 0.1) * 2.0; // Random building height
          vec3 buildingPos = q - vec3(mod(q.x, grid_size), 0.0, mod(q.z, grid_size));
          float building = sdBuilding(buildingPos * 3.0, vec3(boxSize, buildingHeight, boxSize * 3.0) / 3.0) / 3.0;  // Generate a unique "houseNumber" based on the building's grid position

          // Use hash function to introduce randomness for building properties based on the houseNumber
          float houseNumber = floor(buildingPos.x / grid_size) + floor(buildingPos.z / grid_size) * 57.0;  // Unique ID for each building
          float heightFactor = hash(houseNumber + 1.0); // Random value for height variation
          float sizeFactor = hash(houseNumber + 2.0);   // Random value for size variation

          // Apply these random values to alter building height and size
          buildingHeight += heightFactor * 2.0; // Alter height based on houseNumber
          boxSize += sizeFactor * 0.5;          // Alter size based on houseNumber

          // Combine the ground with buildings
          float terrain = min(ground, building);  
      
          // Combine terrain and rain using smooth union or intersection
          float rain = getRain(p - rainPosition, dropRadius, velocityFactor, fogFactor);

          float rainyTerrain = smin(terrain, rain, min(terrain, rain));

          // return opSmoothUnion(ground, building, min(min(box, building), terrain));
          return opSmoothUnion(rainyTerrain, building, smin(min(box, building), terrain, 2.0));
          //return smin(terrain, building, smin(min(box, building), terrain, 2.0));
        }

        float mapDagonWasp(vec3 p) {
          float r = length(p) * 2.616;
          float a = fract(atan(p.y, fract(p.x) - 0.2)) - r;
      
          // Animate 'f' to simulate leg movement using time
          float t = fract(time * 0.25); // slow looping time
          float wave = sin(a * 10.0 + t * 6.2831); // 2Ï€ = full rotation
          float f = abs(wave) * 0.8 + 0.1;
      
          // Optional: add smoother leg outlines with smoothstep
          float softness = smoothstep(-0.5, 1.0, cos(a * 10.0)) * 0.2 + 0.5;
      
          // Final mix with radial distance to simulate a crawl
          float legShape = 1.0 - smoothstep(f, sin(f + r) - 0.25, r);
      
          return legShape;
        }
        
        float dragonSpider(vec3 p) {
          // Create a pseudo distance estimate for SDF
          vec2 proj = p.xz; // Or any plane like xy or yz
          float r = length(proj) * 2.616;
          float a = fract(atan(proj.y, fract(proj.x) - 0.2)) - r;
        
          float f = abs(cos(a * 2.5)) * 0.5 + 0.3;
          f = abs(cos(a * 12.0) * sin(a * 3.0)) * 0.8 + 0.1;
          float softness = smoothstep(-0.5, 1.0, cos(a * 10.0)) * 0.2 + 0.5;
        
          float d = 1.0 - smoothstep(f, sin(f + r) - 0.25, r); // kind of SDF-ish
          return d - 0.5; // shrink a little
        }
      
        float map(vec3) {
          float terrain = mapTerrain(p);
          float creatures = dragonSpider(p);
          return opSmoothUnion(terrain, creatures, smin(min(terrain, creatures), terrain, 2.0));
        }

        vec3 dragonSpiderColor(vec3 p) {
          vec2 proj = p.xz;
          float r = length(proj) * 2.616;
          float a = fract(atan(proj.y, fract(proj.x) - 0.2)) - r;
        
          float f = abs(cos(a * 12.0) * sin(a * 3.0)) * 0.8 + 0.1;
          vec3 color = vec3(1.0 - smoothstep(f, sin(f + r) - 0.25, r));
          return color;
        }

        float angularPattern3D(vec2 proj, float timeFactor, float scale, float freq, float speedOffset) {
          float r = length(proj) * scale;
          float a = atan(proj.y, proj.x);
          a = (a + 3.141592) / 6.283185; // Normalize to [0,1]
          a -= r;
      
          // Smooth oscillating motion
          float t = time * timeFactor + speedOffset;
          float wave = sin(a * freq + t * 6.2831); // 2Ï€ loop
          float f = abs(wave) * 0.8 + 0.1;
      
          float softness = smoothstep(-0.5, 1.0, cos(a * freq)) * 0.2 + 0.5;
          float d = 1.0 - smoothstep(f, sin(f + r) - 0.25, r);
      
          return d * softness;
        }
        
        vec3 renderCreature(vec3 pos, float id) {
          // 1. Compute distance from UV to mouse for interactivity
          float followStrength = 3.0;
          vec2 delta = centeredUV - (mouseUV - 0.5);
          vec3 p = pos;
          p.xy += delta * followStrength;  // creature moves toward mouse
      
          // 2. Choose creature
          float d = (id < 0.5) ? mapDagonWasp(p) : dragonSpider(p);
      
          // 3. Use mouse distance to affect color
          float intensity = smoothstep(0.5, 0.0, length(delta));
          vec3 col = mix(vec3(0.1, 0.1, 0.2), vec3(1.0, 0.6, 0.2), intensity * d);
      
          return col;
        }
















import * as THREE from 'three';

export class TerrestialMosaicMaterials {
  constructor(width = window.innerWidth,
    height = window.innerHeight,
    deltaTime = 1 / 60,
    time = 0.1,
    shapeFactor = 0.5,
    cubeTexture = null,
    explodeIntensity = 0.1,
    thickness = 1,
    flatShading = true,
    u_frequency = 0.0,
    mouse) {
    this.width = width;
    this.height = height;
    this.time = time;
    this.u_frequency = u_frequency;
    this.thickness = thickness;
    this.explodeIntensity = explodeIntensity;
    this.flatShading = flatShading;
    this.deltaTime = deltaTime;
    this.shapeFactor = shapeFactor;
    this.cubeTexture = cubeTexture;
    this.hovered = 0.1;
    this.mouse = mouse;

    // Mouse Utils
    this.mousePosition = this.mouse;
    this.useFluidMosaicShader();
    this.useBlendedMosaicShader();
    this.updateEvents();
    this.getShaders();
  }

  useFluidMosaicShader() {
    this.fluidMosaicShader = {
      uniforms: {
        time: { value: this.time },
        hovered: { value: this.hovered },
        shapeFactor: { value: this.shapeFactor },
        mousePosition: { value: this.mousePosition },
        explodeIntensity: { value: this.explodeIntensity },
        resolution: { value: new THREE.Vector2(this.width, this.height) },
      },

      vertexShader: `
      #ifdef GL_ES
      precision mediump float;
      #endif
      
        uniform float time;
        uniform float hovered;
        uniform vec2 mousePosition;
        uniform float explodeIntensity;
        varying vec2 vUv;
  
        float noise(vec2 p) {
          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }
  
        void main() {
          vUv = uv;
          vec3 pos = position;
      
          // Calculate distance to mouse position
          // float dist = distance(mousePosition, vec2(pos.x, pos.y));
          // float effect = hovered * smoothstep(0.2, 0.0, dist) * noise(pos.xy * 10.0 + time);
      
          // // Apply explode effect
          // pos += normal * effect * explodeIntensity;
    
          // Calculate distance from the mouse to the vertex position
          float dist = distance(mousePosition, uv); // Use UV for spatial mapping
          
          // Apply mouse interaction as distortion (push/pull effect)
          float effect = hovered * smoothstep(0.2, 0.0, dist) * 0.5 * sin(time + dist * 10.0);
          
          // Apply explode effect based on intensity and mouse interaction
          pos += normal * effect * explodeIntensity;
      
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      // CreatureParams waspParams = CreatureParams(2.616, 3.0, 2.5, 12.0, 0.0);
      // CreatureParams spiderParams = CreatureParams(3.4, 8.0, 2.2, 15.0, 0.7);
      // CreatureParams snailParams = CreatureParams(1.2, 1.0, 1.5, 4.0, 0.4);
      
      fragmentShader: `
        #ifdef GL_ES
        precision mediump float;
        #endif
        
        varying vec2 vUv;
        uniform float time;
        uniform float hovered;
        uniform float shapeFactor;
        uniform vec2 mousePosition;
        uniform vec2 resolution;
        uniform float explodeIntensity;

        // Define the size of a building block
        float boxSize = 1.0;
        float buildingHeight = 3.0;
        
        struct CreatureParams {
          float trunkFreq;
          float legFreq1;
          float legFreq2;
          float legFreq3;
          float legPhaseShift;
        };
        
        // Struct for raindrops
        struct RainDrop {
            vec3 position;
            vec3 velocity;
            float size;
            float opacity;
        };
        
        // A simple 2D Perlin Noise function to generate randomness
        float perlinNoise(vec2 p) {
          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }

        // Noise function based on hash
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return clamp(mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y, 0.0, 1.0);
        }

        // Simple float hash function for generating pseudo-random values
        float hash(float x) {
            return fract(sin(x) * 43758.5453123); // A pseudo-random generator based on sin(x)
        }

        // Smoothstep interpolation function for blending
        float S(float t) {
          return t * t * (3.0 - 2.0 * t);
        }
  
        mat2 rot2D(float angle) {
          float s = sin(angle);
          float c = cos(angle);
  
          return mat2(c, -s, s, c);
        }
  
        vec3 rot3D(vec3 p, vec3 axis, float angle) {
          // Rodrigues' Rotation Formula
          return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);
        }

        vec3 rotate3D(vec3 p, vec3 k, float angle) {
          k = normalize(k); // Ensure unit length
          float cosA = cos(angle);
          float sinA = sin(angle);
      
          return p * cosA + cross(k, p) * sinA + k * dot(k, p) * (1.0 - cosA);
        }
        
        // Define smooth union operation
        float opSmoothUnion(float d1, float d2, float k) {
            float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
            return mix(d2, d1, h) + k * h * (1.0 - h);
        }
  
        float opSmoothIntersection(float d1, float d2, float k) {
          float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
          return mix(d2, -d1, h) + k * h * (1.0 - h);
        }
  
        float smin(float a, float b, float k) {
          float h = max(k - abs(a - b), 0.0) / k;
          return min(a, b) - h * h * h * k * (1.0 / 6.0);
        }

        // Signed distance function for a circle
        float sdSphere(vec3 p, float r) {
          return length(p) - r;
        }

        // Create a basic box (building) SDF
        float sdBox(vec3 p, vec3 size) {
          vec3 q = abs(p) - size; 
          return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
        }

        // Create a cuboid box (building) SDF
        float sdBuilding(vec3 p, vec3 size) {
          vec3 d = abs(p) - size;  // Get the distance from the cuboid
          return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
        }

        float sdGround(vec3 p) {
          return p.y + 0.75; // Ground SDF
        }
        
        // Define ground SDF function
        float sdfRoughGround(vec3 p) {
            return p.y + noise(p.xz * 0.1) * 0.5; // Example ground height variation
        }

        // Signed distance function for a cone
        float sdCone(vec3 p, vec3 dir, float height, float radius) {
          // Ensure direction is normalized
          dir = normalize(dir);

          // Project point onto the cone's axis
          float d = dot(p, dir);
          vec3 projected = dir * d;

          // Compute the distance from the projected point to the actual point
          float lateralDist = length(p - projected);
            
          // Compute the expected radius at this height
          float expectedRadius = (d / height) * radius;

          // Compute the signed distance (negative inside, positive outside)
          float distance = lateralDist - expectedRadius;

          // Enforce height limits
          float capBottom = d;
          float capTop = d - height;
            
          // If above the cone's tip or below the base, clamp distance
          return max(distance, max(-capBottom, capTop));
        }

        // Bird body (simplified)
        float sdBirdBody(vec3 p, float size) {
            return sdSphere(p, size);
        }

        // Simplified Bird wings (simplified with two spheres for each wing)
        float sdWing(vec3 p, vec3 wingPos, vec3 birdPos, float wingSize, float angle) {
          // Rotate the wing around the body for animation
          // vec3 rotatedPos = rot3D(p - wingPos, vec3(0.0, 0.0, 1.0), angle) + wingPos;
          vec3 rotatedPos = rot3D(p - wingPos, birdPos, angle) + wingPos;
          return sdSphere(rotatedPos, wingSize); // Using sphere to approximate wing
        }

        // Bird head
        float sdHead(vec3 p, vec3 headPos, float headSize) {
          return sdSphere(p - headPos, headSize);
        }

        // Bird beak
        float sdBeak(vec3 p, vec3 headPos, float beakLength) {
          vec3 beakDir = normalize(p - headPos);
          return sdCone(p - headPos, beakDir, beakLength, 0.1); // A cone for the beak
        }

        // Combine the components to form a bird
        float sdBird(vec3 p, vec3 bodyPos, float bodySize, vec3 wingPos, float wingSize, vec3 headPos, float headSize, float beakLength, float wingAngle) {
          float body = sdBirdBody(p - bodyPos, bodySize);
          // float wing1 = sdWing(p, wingPos, wingSize, wingAngle);
          // float wing2 = sdWing(p, wingPos + vec3(0.5, 0.0, 0.0), wingSize, -wingAngle); // Second wing
          float rightWing = sdWing(p, wingPos, bodyPos, wingSize, wingAngle);
          float leftWing = sdWing(p, wingPos + vec3(0.5, 0.0, 0.0), bodyPos, wingSize, -wingAngle);

          float head = sdHead(p, headPos, headSize);
          float beak = sdBeak(p, headPos, beakLength);
          // Combine parts using smooth union
          return opSmoothUnion(opSmoothUnion(body, rightWing, 0.1), opSmoothUnion(leftWing, opSmoothUnion(head, beak, 0.1), 0.1), 0.1);
        }

        float generateFlock(vec3 q, vec3 birdPos, float bodySize, float wingSize, float headSize, float beakLength, float wingAngle, float ageFactor) {
          // Young birds (light, fly higher, move faster)
          float youngHeight = mix(4.0, 2.0, ageFactor);  
          float youngBirds = sdBird(q, birdPos + vec3(2.0, youngHeight, -1.0), 
                                    bodySize * ageFactor, 
                                    birdPos, wingSize * ageFactor, 
                                    birdPos + vec3(0.0, 0.5, 0.0) * ageFactor, 
                                    headSize * ageFactor, beakLength * ageFactor, wingAngle);
        
          // Mature birds (medium weight, moderate altitude and speed)
          float matureHeight = mix(3.5, 1.5, ageFactor * 0.8);
          float matureBirds = sdBird(q, birdPos + vec3(2.0, matureHeight, -1.0), 
                                    bodySize * ageFactor * 0.5, 
                                    birdPos, wingSize * ageFactor, 
                                    birdPos + vec3(0.0, 0.5, 0.0) * ageFactor, 
                                    headSize * ageFactor, beakLength * ageFactor, wingAngle);
        
          // Aged birds (heavier, fly lower, move slower)
          float agedHeight = mix(2.5, 1.0, ageFactor * 0.6);
          float agedBirds = sdBird(q, birdPos + vec3(-3.0, agedHeight, 2.5), 
                                  bodySize * (ageFactor * 0.8), 
                                  birdPos, wingSize * (ageFactor * 0.8), 
                                  birdPos + vec3(0.0, 0.5, 0.0) * (ageFactor * 0.8), 
                                  headSize * (ageFactor * 0.8), beakLength * (ageFactor * 0.8), wingAngle);
        
          float baseBird = sdBird(q, birdPos, bodySize, birdPos, wingSize, birdPos + vec3(0.0, 0.5, 0.0), headSize, beakLength, wingAngle);
        
          return opSmoothIntersection(min(baseBird, youngBirds),
                                      opSmoothIntersection(youngBirds, matureBirds, min(matureBirds, agedBirds)),
                                      min(baseBird, youngBirds));
        }

        float generateAgeDependentFlock(vec3 q, vec3 birdPos, float bodySize, float wingSize, float headSize, float beakLength, float wingAngle, float ageFactor) {
          float t = time;
        
          // Age-based oscillation amplitude and frequency
          float youngWiggleAmp = 0.3 * (1.0 - ageFactor); // More wiggle for young
          float youngWiggleFreq = 5.0 * (1.0 - ageFactor); // Faster wiggle for young
          float matureWiggleAmp = 0.15 * (1.0 - ageFactor * 0.8);
          float matureWiggleFreq = 3.0 * (1.0 - ageFactor * 0.8);
          float agedWiggleAmp = 0.05 * (1.0 - ageFactor * 0.6);
          float agedWiggleFreq = 1.5 * (1.0 - ageFactor * 0.6);
        
          // Apply wiggling offsets (x and y directions for a more organic look)
          vec3 youngOffset = vec3(
            sin(t * youngWiggleFreq + 1.0) * youngWiggleAmp,
            mix(4.0, 2.0, ageFactor),
            cos(t * youngWiggleFreq + 1.5) * youngWiggleAmp
          );
          vec3 matureOffset = vec3(
            sin(t * matureWiggleFreq + 2.0) * matureWiggleAmp,
            mix(3.5, 1.5, ageFactor * 0.8),
            cos(t * matureWiggleFreq + 2.5) * matureWiggleAmp
          );
          vec3 agedOffset = vec3(
            sin(t * agedWiggleFreq + 3.0) * agedWiggleAmp,
            mix(2.5, 1.0, ageFactor * 0.6),
            cos(t * agedWiggleFreq + 3.5) * agedWiggleAmp
          );
        
          // Young bird
          float youngBirds = sdBird(q, birdPos + vec3(2.0, 0.0, -1.0) + youngOffset, 
                                    bodySize * ageFactor, 
                                    birdPos, wingSize * ageFactor, 
                                    birdPos + vec3(0.0, 0.5, 0.0) * ageFactor, 
                                    headSize * ageFactor, beakLength * ageFactor, wingAngle);
        
          // Mature bird
          float matureBirds = sdBird(q, birdPos + vec3(2.0, 0.0, -1.0) + matureOffset, 
                                     bodySize * ageFactor * 0.5, 
                                     birdPos, wingSize * ageFactor, 
                                     birdPos + vec3(0.0, 0.5, 0.0) * ageFactor, 
                                     headSize * ageFactor, beakLength * ageFactor, wingAngle);
        
          // Aged bird
          float agedBirds = sdBird(q, birdPos + vec3(-3.0, 0.0, 2.5) + agedOffset, 
                                   bodySize * (ageFactor * 0.8), 
                                   birdPos, wingSize * (ageFactor * 0.8), 
                                   birdPos + vec3(0.0, 0.5, 0.0) * (ageFactor * 0.8), 
                                   headSize * (ageFactor * 0.8), beakLength * (ageFactor * 0.8), wingAngle);
        
          // Main bird (leader or origin reference)
          float baseBird = sdBird(q, birdPos, bodySize, birdPos, wingSize, birdPos + vec3(0.0, 0.5, 0.0), headSize, beakLength, wingAngle);
        
          // Smooth blending into one flock
          return opSmoothIntersection(
                   min(baseBird, youngBirds),
                   opSmoothIntersection(youngBirds, matureBirds, min(matureBirds, agedBirds)),
                   min(baseBird, youngBirds));
        }
        
        // Main Map with birds in the scene
        float mapTerrain(vec3 p) {
          // Sun
          vec3 sunPos = vec3(sin(time) * 3.0, 9.0, -90.0); // Sun Position
          float sun = sdSphere(p - sunPos, 1.0); // Sphere SDF

          // Bird position and movement based on time
          float bodySize = 0.5;
          float wingSize = 0.2;
          float headSize = 0.2;
          float beakLength = 0.1;
          float wingAngle = sin(time * 2.0) * 0.5; // Flapping wing animation
          vec3 birdPos = vec3(sin(time) * 3.0, cos(time) * 3.0, time); // Bird movement

          // Streets and Parkways, Create building SDF and place it on street
          // Use mod(p.x, grid_size) and mod(p.z, grid_size) for infinite grid layout
          float grid_size = 15.0;  // Grid spacing for streets & buildings
          float road_width = 2.5;  // Adjust road widthfloat grid_size = 15.0;

          // Age Factor
          float ageFactor = 0.5 + 0.3 * sin(time * 2.0);  // Dynamic size variation
  
          vec3 q = p; // input copy

          // Weather Factor the ommitted swizzled vec param is the axis of rotation
          q.z += time * 0.4; // Forward Camera Movement  
          q.xz = fract(p.xz) - 0.5; // Space Repetition 0.5 is the center of repetition
          q.y -= time * 0.4; // Upward Movement
          // q.xz *= rot2D(fract(time * 4.0) - 0.5); 
  
          // float box = sdBox(q * 3.0, vec3(0.15)) / 3.0; 
          q = fract(p) - 0.5; // Space Repetition 0.5 is the center of repetition
          
          // fluid lines float box = sdBox(q * 3.0, vec3(0.15) * 3.0) / 3.0; // Scaled Cube SDF

          // Calculate building's position based on street number
          float buildingSize = 1.0;
          float buildingHeight = 3.0 + noise(q.xz * 0.1) * 2.0; // Random building height
          vec3 buildingPos = q - vec3(mod(q.x, grid_size), 0.0, mod(q.z, grid_size));

          // Address building properties based on the houseNumber
          float houseNumber = floor(buildingPos.x / grid_size) + floor(buildingPos.z / grid_size) * 57.0;  // Unique ID for each building
          float heightFactor = hash(houseNumber + 1.0); // Random value for height variation
          float sizeFactor = hash(houseNumber + 2.0);   // Random value for size variation

          // Apply these random values to alter building height and size
          buildingHeight += heightFactor * 2.0; // Alter height based on houseNumber
          buildingSize += sizeFactor * 0.5;          // Alter size based on houseNumber
          float building = sdBuilding(buildingPos * 3.0, vec3(buildingSize, buildingHeight, buildingSize * 3.0) / 3.0) / 3.0;  // Generate a unique "houseNumber" based on the building's grid position

          // Generate birds
          float bird = sdBird(q, birdPos, bodySize, birdPos, wingSize, birdPos, headSize, beakLength, wingAngle);
          float flock = generateFlock(q * 3.0, birdPos, bodySize, wingSize, headSize, beakLength, wingAngle, ageFactor) / 3.0;
          birdPos += q - vec3(mod(q.x, grid_size), 6.0 * time, mod(q.z, grid_size));

          // ground 
          float ground = sdGround(p);
          float terrain = min(min(ground, sun), building); 
          float terrainBirds = opSmoothIntersection(terrain, min(bird, flock), min(flock, terrain)); 
          float flockTerrain = opSmoothIntersection(terrainBirds, min(flock, terrain), min(flock, terrain)); 
  
          // To combine the two shapes using the union operator
          return opSmoothUnion(terrain, opSmoothUnion(min(building, flock), terrainBirds, opSmoothUnion(terrain, flock, terrainBirds)), min(flock, terrain));
        }

        // Function to calculate the distance to the surface of the dragon shape
        float sdDragonShape(vec3 p) {
            // Trunk Calculation
            float r = length(p) * 2.616;
            float a = fract(atan(p.y, fract(p.x) - 0.2)) - r;
        
            // Legs and Shape Calculation
            float f = cos(a * fract(11.472) - 0.708);
            f = abs(cos(a * 3.));
            f = abs(cos(a * 2.5)) * 0.5 + 0.3;
            f = abs(cos(a * 12.) * sin(a * 3.)) * 0.8 + 0.1;
            f = smoothstep(-0.5, 1.0, cos(a * 10.)) * 0.2 + 0.5;
        
            // Return distance to the surface of the dragon
            return fract(smoothstep(f, sin(f + r) - 0.268, r)) - 0.5;
        }

        float getCreatureShape(vec3 p, CreatureParams cp) {
          // Trunk - radial displacement
          float r = length(p.xy) * cp.trunkFreq;
          float a = fract(atan(p.y, fract(p.x) - 0.2)) - r;
      
          // Legs - procedural pattern from angles
          float f = 0.0;
      
          f += abs(cos(a * cp.legFreq1));
          f += abs(cos(a * cp.legFreq2)) * 0.5 + 0.3;
          f += abs(cos(a * cp.legFreq3) * sin(a * cp.legFreq1)) * 0.8 + 0.1;
          f += smoothstep(-0.5, 1.0, cos(a * cp.legFreq2 + cp.legPhaseShift)) * 0.2 + 0.5;
      
          return f;
        }
      
        float sdWaspSwarm(vec3 p) {
          float res = 1e5;
          for (int i = 0; i < 20; i++) {
              float fi = float(i);
              vec3 offset = vec3(sin(fi * 7.1 + time), cos(fi * 3.7 + time * 0.5), sin(fi * 5.3));
              offset *= 5.0;
              float d = sdDragonShape(p - offset); // Your wasp sdf
              res = min(res, d);
          }
          return res;
        }
      
        float mapBugs(vec3 p) {
          float d = 1e5;
          int bugCount = 25;
          float swarmRadius = 6.0;
      
          for (int i = 0; i < bugCount; ++i) {
              float fi = float(i);
              float angle = fi * 3.14 * 2.0 / float(bugCount);
              
              vec3 center = vec3(
                  sin(angle + time * 0.5),
                  cos(angle * 1.3 + time) * 0.5 + 2.0,
                  cos(angle + time * 0.3)
              ) * swarmRadius;
      
              // interpolate smooth buzz
              vec3 bugPos = mix(center, center + vec3(0.5, 0.2, 0.0), sin(time * 2.0 + fi) * 0.5 + 0.5);
              
              d = min(d, sdDragonShape(p - bugPos));
          }
      
          return d;
        }
        
        // vec3 sdWasp(vec3 p) {
        //       // vec2 pos = vec2(0.550,0.540)-uv;
          
        //       // trunk
        //       float r = length(p)*2.616;
        //       float a = fract(atan(p.y,fract(p.x) - 0.2)) - r;
          
        //       // Legs
        //       float f = cos(a*fract(11.472) - 0.708);
        //       f = abs(cos(a*3.));
        //       f = abs(cos(a*2.5))*.5+.3;
        //       f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
        //       f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

        //       // combine body
        //       float wasp = smoothstep(sqrt(r + time), fract(f * sin(a + r)), smin(r, a * f, f));
          
        //       vec3 bugStructure = vec3( 1.-smoothstep(f, sin(f + r)+-0.268,r) );
        //       float dragon = sdWaspSwarm(
        //         vec3(
        //           wasp, 
        //           1.0 - smoothstep(
        //               f, 
        //               sin(f + r) + -0.268),
        //               bugStructure
        //             ),
        //           bugStructure
        //           )
        //         );
        //       return dragon;
        //   }
        // }
        
        // Main Map
        float map(vec3 p) {
          float terrain = mapTerrain(p);
          float bugs = mapBugs(p);
          float scene = smin(terrain, bugs, smoothstep(terrain, bugs, sin(terrain + bugs)));
          return scene;
        }

        // // Main Renderer
        // float raymarch(vec3 ro, vec3 rd, out vec3 p) {
        //   float t = 0.0;
        //   for (int i = 0; i < 100; i++) {
        //       p = ro + t * rd;
        //       float d = map(p);
        //       if (d < 0.001) return t;
        //       t += d;
        //       if (t > 100.0) break;
        //   }
        //   return t;
        // }

        // float mapCreatures(vec3 p) {
        //   float d = 1e5;
      
        //   // Creature 1 - Crab walker
        //   vec3 crabOffset = vec3(sin(time) * 2.0, 0.3, cos(time) * 2.0);
        //   d = min(d, getCreatureShape(p - crabOffset, crab));
      
        //   // Creature 2 - Floating Jelly
        //   vec3 jellyOffset = vec3(sin(time * 0.7) * 1.5, 2.0 + sin(time * 1.2) * 0.5, cos(time * 0.8) * 1.5);
        //   d = min(d, getCreatureShape(p - jellyOffset, jelly) * 0.8); // smaller jelly
      
        //   // Creature 3 - Spider scuttler
        //   vec3 spiderOffset = vec3(1.0 + sin(time * 1.5), 0.1, -2.0 + cos(time * 2.0));
        //   d = min(d, getCreatureShape(p - spiderOffset, spider));
      
        //   // Creature 4 - Alien stalker
        //   vec3 alienOffset = vec3(cos(time * 0.3) * 3.0, 1.5 + sin(time * 0.4), sin(time * 0.3) * 3.0);
        //   d = min(d, getCreatureShape(p - alienOffset, alien) * 1.2); // maybe larger
      
        //   return d;
        // }

        // vec3 animalGlow(vec3 p, CreatureParams cp, vec3 baseColor, float intensity, float glowRange) {
        //   float shape = getCreatureShape(p, cp);
        //   float glow = exp(-shape * glowRange) * intensity;
        //   return baseColor * glow;
        // }
      
        vec3 computeNormal(vec3 p) {
          float epsilon = 0.001;
          return normalize(vec3(
            map(p + vec3(epsilon, 0, 0)) - map(p - vec3(epsilon, 0, 0)),
            map(p + vec3(0, epsilon, 0)) - map(p - vec3(0, epsilon, 0)),
            map(p + vec3(0, 0, epsilon)) - map(p - vec3(0, 0, epsilon))
          ));
        }

        // Function to compute soft shadows
        float computeSoftShadow(vec3 p, vec3 lightPos) {
          vec3 shadowDir = normalize(lightPos - p);
          float shadowT = 0.1; // Small initial offset to avoid self-shadowing
          float shadowFactor = 1.0;
          float maxDist = 5.0;

          for (int j = 0; j < 24; j++) { // Optimized loop count
            vec3 shadowPoint = p + shadowDir * shadowT;
            float shadowDist = map(shadowPoint);
                
            if (shadowDist < 0.001) {
              shadowFactor *= 0.5; // Reduce intensity for occlusion
            }
                
            shadowT += shadowDist * 0.5; // Smaller steps improve softness
            if (shadowT > maxDist) break; // Stop marching if too far
          }

          return clamp(shadowFactor, 0.2, 1.0); // Ensure valid shadow range
        }
      
        vec3 computeCameraPosition(float time) {
          float radius = 5.0; // Adjust for larger or smaller movement
          float speed = 0.5; // Adjust rotation speed
      
          float camX = radius * cos(time * speed);
          float camZ = radius * sin(time * speed);
          
          return vec3(camX, 1.5, camZ - 3.0); // Y-position can be adjusted for height
        }

        vec3 centerAspectView(vec2 u, vec2 m) {
          float pct = 0.0;
      
          // a. The DISTANCE from the pixel to the center
          // pct = distance(u,vec2(0.5));
      
          // b. The LENGTH of the vector from the pixel to the center
          // vec2 auv = vec2(0.5)-u;
          // pct = length(auv);
          vec2 auv = vec2(m + 0.5)- u;
          pct = length(auv);
      
          // c. The SQUARE ROOT of the vector
          //    from the pixel to the center
          // vec2 c = vec2(0.5)-u;
          // pct = sqrt(c.x*c.x+c.y*c.y);
          return vec3(pct);
        }

        vec3 applyFog(vec3 color, float distance, vec3 fogColor, float fogDensity) {
          float fogFactor = exp(-distance * fogDensity); // Exponential fog
          return mix(fogColor, color, fogFactor); // Blend fog with scene color
        }

        void wiggleCamera(inout vec3 ro, inout vec3 rd, vec2 uv, vec2 mouse, float time) {
          // Adding wiggle effect to the camera
          ro.x += sin(time * 2.0) * 0.5;
          ro.y += cos(time * 1.5) * 0.2;
          
          // Slight noise-based distortion on ray direction
          rd += normalize(vec3(
              sin(uv.x * time * 0.5) * 0.1,  
              cos(uv.y * time * 0.3) * 0.1,  
              sin(uv.x * time * 0.7) * 0.1  
          ));

          rd = normalize(rd); // Normalize direction after adding noise

          // Camera rotations
          ro.yz *= rot2D(-mouse.y);
          rd.yz *= rot2D(-mouse.y);

          ro.xz *= rot2D(-mouse.x);
          rd.xz *= rot2D(-mouse.x);
        }

        vec3 colorPalette(vec2 uv, float t, float lightIntensity, float shadowIntensity, float depthFactor) {
          vec3 uvt = vec3(uv, smoothstep(mouse.x, mouse.y, t));
          float rayPower = t * 0.2 * depthFactor;
          float redBlend = blendView(uvt, fract(dragonSpider(uvt * t)));
          float blueButter = shadowIntensity + rayPower + S(noise(uv.xy * 2.0 + t * 0.7)) * shadowIntensity;
          float bt = smoothTime(blueButter + t);
          float greenMoney = smoothstep(bt, sin(t + bt), sqrt(t + uv.x));
      
          float rgR = smoothstep(shadowIntensity, rayPower + S(noise(uv.xy * 4.0 + t * 0.3)), shadowIntensity); 
          float rgG = sqrt(shadowIntensity + rayPower + S(noise(uv.yx * 3.0 + t * 0.5)) * smoothTime(shadowIntensity));
          float rgB = smoothTime(blueButter + t);
      
          vec3 colorBlend = vec3(rgR, rgG, rgB);
          vec3 colorDust = vec3(smoothTime(redBlend), t + mouse.x, sqrt(redBlend));
          
          return mix(colorBlend, colorDust, redBlend * blueButter);
        }
      
        void main() {
          // UV Mapping
          vec2 fragCoord = gl_FragCoord.xy;
          vec2 uv = fragCoord / resolution; // Proper UV mapping
          // uv.x *= resolution.x / resolution.y;

          // Normalize Mouse normalized to same space (assuming it's passed in already as [0, res])
          vec2 mouse = (mousePosition * 2.0 - 1.0); // Convert to [-1, 1] range
          vec2 mouseUV = mousePosition / resolution;
        
          // Aspect ratio correction for final rendering only, not for distance
          vec2 aspectUV = uv;
          aspectUV.x *= resolution.x / resolution.y;
      
          // // UV Transformations
          // uv *= 2.0 + time;
          // uv *= 1.2 + noise(uv * time) * 0.05;  // Slight noise-based distortion
          // vec3 color = vec3(distance(mousePosition, uv));

          // vec2 sp = vec2(0.5)-uv;
          // vec3 p = vec3(sp, uv.x);
      
          // // trunk
          // float r = length(p)*2.616;
          // float a = fract(atan(p.y,fract(p.x) - 0.2)) - r;
      
          // // Legs
          // float f = cos(a*fract(11.472) - 0.708);
          // f = abs(cos(a*3.));
          // f = abs(cos(a*2.5))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
      
          // vec3 waspVert = vec3( 1.-smoothstep(f, sin(f + r)+-0.268,r));
          // color = vec3( 1.-smoothstep(f, sin(f + r)+-0.268,r));
          // color *=  centerAspectView(uv, mouse);

          // Apply depth factor
          // float rayPower = t * 0.003 * lightIntensity * depthFactor * shadowIntensity;

          float fov = 1.0;
          float depthFactor = 0.064;
          float shadowIntensity = 0.1;
          float lightIntensity = 0.02;

          vec3 ro = vec3(uv, -3.0); // Ray Origin
          vec3 rd = normalize(vec3(uv * fov, 1.0)); // Ray Direction

          // ðŸ”¥ðŸ”¥ Ray Marching Algorithm
          float t = 0.0; // Total Distance Travelled By Ray
          vec3 normal; // Declare normal
          vec3 color = vec3(t);
          // vec3 color = vec3(t * time * 0.2 * depthFactor + noise(uv.xy * 3.0 + time * 0.5));
      
          // Ray Marching Algorithm
          for (int i = 0; i < 80; i++) {
              vec3 p = ro + rd * t; // Position along the ray
              float d = map(p); // Current distance to the scene
              // lightDir = normalize(lightPos - p);

              // Apply wiggle effect to the camera
              wiggleCamera(ro, rd, uv, mouse, time);
                  
              // Compute Shadows and reflections
              if (d < 0.001) {  
                normal = computeNormal(p); // âœ… Compute surface normal here vec3 p, vec3 lightPos
                float shadow = computeSoftShadow(p + normal, lightPos);
                shadowIntensity = computeSoftShadow(p, lightPos); // Call function
                break;
      
              t += d; // March the distance
      
              color = vec3(i) / 80.0; // Grey Depth Coloring
              color *= shadowIntensity; // Apply shadow effect
      
              if (d < 0.001 || t > 100.0) break;
          }

          // Apply depth factor
          float rayPower = t * 0.003 * lightIntensity * depthFactor * shadowIntensity;

          // float shadowIntensity = computeSoftShadow(ro + rd * t, lightPos);
          vec3 baseColor = colorPalette(uv, time, shadowIntensity, depthFactor);

          // // Color Pallete
          // Depth FactordragonSpiderColor(uvt)
          vec3 uvt = vec3(uv, smoothstep(mouse.x, mouse.y, time));
          float rayPower = t * 0.2 * depthFactor;
          float redBlend = blendView(uvt, fract(dragonSpider(uvt * time)));
          float blueButter = shadowIntensity + rayPower + S(noise(uv.xy * 2.0 + time * 0.7)) * shadowIntensity;
          float greenMoney = smoothstep(bt, sin(time + bt), sqrt(time + uv.x));
          float bt = smoothTime(blueButter + time);
          float rgR = smoothstep(shadowIntensity, (rayPower + S(noise(uv.xy * 4.0 + time * 0.3)) ), shadowIntensity); 
          float rgG = sqrt(shadowIntensity + rayPower + S(noise(uv.yx * 3.0 + time * 0.5)) * smoothTime(shadowIntensity));
          float rgB = smoothTime(blueButter + time);
          vec3 colorBlend = vec3(rgR, rgG, rgB);
          vec3 colorDust = vec3(smoothTime(redBlend, bt, sin(rgR*rgB)), time + mouse.x, sqrt(redBlend));
          vec3 colorButter = mix(colorBlend, colorDust, redBlend * blueButter);

          // Check if hovered is active or not
          if (hovered > 0.0) {
            // Mouse is hovering, apply mouse interaction effects
            float dist = distance(mousePosition, uv);
            float absT =  abs(sin(time));
            // dist +=  absT;
            
            // Use the distance to influence the color (make mouse position cause a color shift)
            color = vec3(1.0 - dist, 1.0 - dist, 1.0); // Makes the area closer to the mouse lighter (for visible effect)
            
            // Use distance to control the opacity
            float opacity = smoothstep(0.0, 0.5, dist); // Opacity decreases with distance from the mouse position

            // Optionally, add time-based animation for extra dynamics
            color *= 0.5 + 0.5 * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and time
            vec3 colorPallete = mix(color, colorBlend, smoothstep(redBlend, blueButter, greenMoney));
            color += mix(color, colorPallete, time);//fract( * absT); //, sin(dist * (uv.x + time)));
        
            gl_FragColor = vec4(color, opacity);
          } else {
            // Mouse is not hovering, apply default effect based on UV coordinates and distance
            float dist = distance(uv, vec2(0.5, 0.5)); // Default base distance, could be replaced with your original calculation
            // dist *= centerAspectView(uv, mouse);
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Use original UV-distance-based coloring
            color *= 0.5 + 0.5 * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and time
            float opacity = smoothstep(0.6, 0.8, 1.0);
            gl_FragColor = vec4(color, opacity); // Default behavior
          }
        }
        
      `
    }

    this.fluidMosaicMaterial = new THREE.ShaderMaterial(this.fluidMosaicShader);
  }

  useBlendedMosaicShader() {
    this.blendedMosaicShader = {
      uniforms: {
        time: { value: this.time },
        hovered: { value: this.hovered },
        shapeFactor: { value: this.shapeFactor },
        mousePosition: { value: this.mousePosition },
        explodeIntensity: { value: this.explodeIntensity },
        resolution: { value: new THREE.Vector2(this.width, this.height) },
      },

      vertexShader: `
      #ifdef GL_ES
      precision mediump float;
      #endif
      
        uniform float time;
        uniform float hovered;
        uniform vec2 mousePosition;
        uniform float explodeIntensity;
        varying vec2 vUv;
  
        float noise(vec2 p) {
          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }
  
        void main() {
          vUv = uv;
          vec3 pos = position;
      
          // Calculate distance to mouse position
          // float dist = distance(mousePosition, vec2(pos.x, pos.y));
          // float effect = hovered * smoothstep(0.2, 0.0, dist) * noise(pos.xy * 10.0 + time);
      
          // // Apply explode effect
          // pos += normal * effect * explodeIntensity;
    
          // Calculate distance from the mouse to the vertex position
          float dist = distance(mousePosition, uv); // Use UV for spatial mapping
          
          // Apply mouse interaction as distortion (push/pull effect)
          float effect = hovered * smoothstep(0.2, 0.0, dist) * 0.5 * sin(time + dist * 10.0);
          
          // Apply explode effect based on intensity and mouse interaction
          pos += normal * effect * explodeIntensity;
      
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,

      fragmentShader: `
        #ifdef GL_ES
        precision mediump float;
        #endif
        
        varying vec2 vUv;
        uniform float time;
        uniform float hovered;
        uniform float shapeFactor;
        uniform vec2 mousePosition;
        uniform vec2 resolution;
        uniform float explodeIntensity;

        // Define the size of a building block
        float boxSize = 1.0;
        float buildingHeight = 3.0;

        // Noise function based on hash
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return clamp(mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y, 0.0, 1.0);
        }

        // Simple float hash function for generating pseudo-random values
        float hash(float x) {
            return fract(sin(x) * 43758.5453123); // A pseudo-random generator based on sin(x)
        }

        // Smoothstep interpolation function for blending
        float S(float t) {
          return t * t * (3.0 - 2.0 * t);
        }

        mat2 rot2D(float angle) {
          float s = sin(angle);
          float c = cos(angle);
  
          return mat2(c, -s, s, c);
        }
  
        vec3 rot3D(vec3 p, vec3 axis, float angle) {
          // Rodrigues' Rotation Formula
          return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);
        }

        vec3 rotate3D(vec3 p, vec3 k, float angle) {
          k = normalize(k); // Ensure unit length
          float cosA = cos(angle);
          float sinA = sin(angle);
      
          return p * cosA + cross(k, p) * sinA + k * dot(k, p) * (1.0 - cosA);
        }

        // Signed distance function for a circle
        float sdCircle(vec2 p, float radius) {
          return length(p) - radius;
        }
  
        float sdSphere(vec3 p, float r) {
          return length(p) - r;
        }

        // Create a basic box (building) SDF
        float sdBox(vec3 p, vec3 size) {
          vec3 q = abs(p) - size; 
          return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
        }

        // Create a cuboid box (building) SDF
        float sdBuilding(vec3 p, vec3 size) {
          vec3 d = abs(p) - size;  // Get the distance from the cuboid
          return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
        }
        
        // Define ground SDF function
        float sdGround(vec3 p) {
            return p.y + noise(p.xz * 0.1) * 0.5; // Example ground height variation
        }
        
        // Define smooth union operation
        float opSmoothUnion(float d1, float d2, float k) {
            float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
            return mix(d2, d1, h) + k * h * (1.0 - h);
        }
  
        float opSmoothIntersection(float d1, float d2, float k) {
          float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
          return mix(d2, -d1, h) + k * h * (1.0 - h);
        }
  
        float smin(float a, float b, float k) {
          float h = max(k - abs(a - b), 0.0) / k;
          return min(a, b) - h * h * h * k * (1.0 / 6.0);
        }
        
      `
    };

    this.blendedMosaicMaterial = new THREE.ShaderMaterial(this.blendedMosaicShader);
  }

  getShaders() {
    this.shaders = [
      this.fluidMosaicShader, 
      this.blendedMosaicShader
    ];
  }
  updateResolution(shader, width, height) {
    if (shader && shader.uniforms && shader.uniforms.resolution) {
      shader.uniforms.resolution.value.set(width, height);
    }
  }

  handleResize(renderer, width = window.innerWidth, height = window.innerHeight) {
    if (!renderer) return;
    // Each shader handles its own resolution updates
    if (this.fluidMosaicShader) this.updateResolution(this.fluidMosaicShader, width, height);
  }
  
  updateMouseExit() {
    this.shaders.forEach(shader => {
      if (shader?.uniforms?.hovered) {
        shader.uniforms.hovered.value = 0.0;
      }
    });
  }
  
  handleMouseMove(event) {
    if (event && this.mousePosition) {
      this.mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
      this.mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    this.shaders.forEach(shader => {
      if (!shader?.uniforms) return;
      
      const { uniforms } = shader;
  
      if (uniforms.hovered) uniforms.hovered.value = 1.0;
      if (uniforms.mousePosition) uniforms.mousePosition.value.set(this.mousePosition.x, this.mousePosition.y);
      if (uniforms.explodeIntensity) uniforms.explodeIntensity.value = Math.sin(this.explodeIntensity + this.time);
      if (uniforms.shapeFactor) uniforms.shapeFactor.value = this.shapeFactor + (this.time * Math.sin(0.001 + this.time));
    });
  }
  
  updateEvents() {
    // Only bind listeners once
    window.addEventListener('mousemove', (e) => this.handleMouseMove(e));
    window.addEventListener('mouseout', () => this.updateMouseExit());
  }

  update() {
    // this.updateEvents()
    this.time += this.deltaTime; // Update time for animation

    // Update other uniforms if necessary
    if (this.fluidMosaicShader) {
      this.fluidMosaicShader.uniforms.shapeFactor.value = this.time * Math.sin(0.001 + this.time);
      this.fluidMosaicShader.uniforms.time.value = (Math.sin(this.time) * 0.5) + 0.5 + Math.cos(0.1 + this.time);
      this.fluidMosaicShader.uniforms.explodeIntensity.value = (Math.sin(this.time) * 0.5) + 0.5 + Math.cos(0.1 + this.time);
    }

    if (this.blendedMosaictShader) {
      this.blendedMosaictShader.uniforms.shapeFactor.value = this.time * Math.sin(0.001 + this.time);
      this.blendedMosaictShader.uniforms.time.value = (Math.sin(this.time) * 0.5) + 0.5 + Math.cos(0.1 + this.time);
      this.blendedMosaictShader.uniforms.explodeIntensity.value = (Math.sin(this.time) * 0.5) + 0.5 + Math.cos(0.1 + this.time);
    }
  }
}
export default TerrestialMosaicMaterials;

float rollingSpace(vec2 u) {
    
    vec3 p = vec3(0.0, 0.0, -19.0 * time);

    vec2 pos = vec2(0.5)-u;

    float xs = 0.001 * time;
    float sm = 0.01 * time;
    
    float r = length(pos)*2.0;
    float smr = smoothstep(xs -r * tan(pow(0.1*pos.x, pos.y)), r+pos.x, atan(tan(r * sm), pos.y));
    float h = sin(r) * sin(smr + r);
    float a = atan(pos.y,pos.x) - smr * sin(xs);
    float pol = atan(pos.y,pos.x) - smr *h;
    float cyc = atan(pos.y,pos.x) - smr -h *a;
    pol *= atan(cyc, pol);// Horse Runner
    // a  = atan(pos.y,pos.x) - smr - (time + tan(pos.y)); wheel circus
    a += pol; // Dirty Bug
    a *= pol; //* sqrt(a * time); // Dirty Bug
    // a = pol; //* sqrt(a * time); // Motion Flower
    float csn = a*pol;
	a += csn * fract (sin(a* p.z *time) ) + time;
	float rollMill = a + (csn * fract (sin(a* p.z *time) ) + time /p.z);
	// float fan = a + (csn * fract (sin(a+ p.z *time) ) + time);
    // a = fan;
    a = rollMill;
    float ac = cos(cyc-a*3.+ pow(cyc, pol)) / pol * csn;
    float as = sin(cyc-a*3.+ pow(cyc, pol));
    float f = cos(cyc-a*3.+ pow(cyc * tan(0.6), pol)) * 21.976*(as / pol) * csn;
    // f = min(as,ac+tan(pol* 13.0 * time));
    // f = abs(cos(a*3.));
    // f += fract(sin(a*2.5))*0.644+.3 - f;
    // f = abs(cos(a*12.)*sin(a*3.296))*0.904+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.264+0.580;

    return 1.-smoothstep(f,f+0.02,r);
}


    vec3 p = vec3(0.0, 0.0, -9.0 * time);

    vec2 pos = vec2(0.5)-uv;

    float xs = 0.001 * time;
    float sm = 0.01 * time;
    
    float r = length(pos)*2.0;
    float smr = smoothstep(r* tan(atan(pos.x, pos.y)), r+pos.x, atan(tan(r * sm), pos.y));
    float h = sin(r) * sin(smr);
    float a = atan(pos.y,pos.x) - smr;
    float pol = atan(pos.y,pos.x) - smr *h * a;
    float cyc = atan(pos.y,pos.x) - smr -h *a;
    pol *= atan(cyc, pol);// Horse Runner
    // a  = atan(pos.y,pos.x) - smr - (time + tan(pos.y)); wheel circus
    a += pol; // Dirty Bug
    a *= pol; //* sqrt(a * time); // Dirty Bug
    // a = pol; //* sqrt(a * time); // Motion Flower
    float csn = a*pol;
	a += csn * fract (sin(a* p.z *time) ) + time;
	float rollMill = a + (csn * fract (sin(a* p.z *time) ) + time);
	// float fan = a + (csn * fract (sin(a+ p.z *time) ) + time);
    // a = fan;
    // a = rollMill;
    float ac = cos(cyc-a*3.+ pow(cyc, pol)) / pol * csn;
    float as = sin(cyc-a*3.+ pow(cyc, pol));
    float f = as - cos(a*3.* pow(cyc * tan(1.168), pol)) * 21.976*(as / pol) * csn;
    f = min(as,ac+tan(pol* 13.0));
    // f = abs(cos(a*3.));
    // f = abs(sin(a*2.5))*0.652+.3;
    // f = abs(cos(a*12.)*sin(a*3.296))*0.904+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.264+0.580;

    color = vec3( 1.-smoothstep(f,f+0.02,r) );



        fragmentShader: `
        #ifdef GL_ES
        precision mediump float;
        #endif
        
        varying vec2 vUv;
        uniform float time;
        uniform float hovered;
        uniform float shapeFactor;
        uniform vec2 mousePosition;
        uniform vec2 resolution;
        uniform float explodeIntensity;

        // Define the size of a building block
        float boxSize = 1.0;
        float buildingHeight = 3.0;

        // Noise function based on hash
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return clamp(mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y, 0.0, 1.0);
        }

        // Simple float hash function for generating pseudo-random values
        float hash(float x) {
            return fract(sin(x) * 43758.5453123); // A pseudo-random generator based on sin(x)
        }

        // Smoothstep interpolation function for blending
        float S(float t) {
          return t * t * (3.0 - 2.0 * t);
        }
        
        // Define smooth union operation
        float opSmoothUnion(float d1, float d2, float k) {
            float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
            return mix(d2, d1, h) + k * h * (1.0 - h);
        }
  
        float opSmoothIntersection(float d1, float d2, float k) {
          float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
          return mix(d2, -d1, h) + k * h * (1.0 - h);
        }
  
        float smin(float a, float b, float k) {
          float h = max(k - abs(a - b), 0.0) / k;
          return min(a, b) - h * h * h * k * (1.0 / 6.0);
        }

        mat2 rot2D(float angle) {
          float s = sin(angle);
          float c = cos(angle);
  
          return mat2(c, -s, s, c);
        }
  
        vec3 rot3D(vec3 p, vec3 axis, float angle) {
          // Rodrigues' Rotation Formula
          return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);
        }

        vec3 rotate3D(vec3 p, vec3 k, float angle) {
          k = normalize(k); // Ensure unit length
          float cosA = cos(angle);
          float sinA = sin(angle);
      
          return p * cosA + cross(k, p) * sinA + k * dot(k, p) * (1.0 - cosA);
        }

        // Signed distance function for a circle
        float sdSphere(vec3 p, float r) {
          return length(p) - r;
        }

        // Create a basic box (building) SDF
        float sdBox(vec3 p, vec3 size) {
          vec3 q = abs(p) - size; 
          return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
        }

        // Create a cuboid box (building) SDF
        float sdBuilding(vec3 p, vec3 size) {
          vec3 d = abs(p) - size;  // Get the distance from the cuboid
          return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
        }
        
        // Define ground SDF function
        float sdfGround(vec3 p) {
            return p.y + noise(p.xz * 0.1) * 0.5; // Example ground height variation
        }

        // The main map function that will define the scene
        float mapTerrain(vec3 p) {
          // Define building parameters
          vec3 spherePos = vec3(-5.0 * sin(time * 5.0), 2.0, 0.0);
          // spherePos += rotate3D(spherePos, vec3(1.0, 0.5, 0.0), time * 0.3);
          float sphere = sdSphere(p - spherePos, 0.9);

          // Ground SDF
          float ground = sdfGround(p);
          // p += rot3D(p, p.xy, angle);  
  
          // Infinite city generation
          vec3 q = p; // input copy

          // Weather Factor the ommitted swizzled vec param is the axis of rotation
          q.z += time * 0.4; // Forward Camera Movement  
          q.y -= time * 0.4; // Upward Movement

          // q.xz *= rot2D(time * 0.4);
          q = fract(p) - 0.5; // Space Repetition 0.5 is the center of repetition
          //q.xz = fract(p.xz) - 0.5; // Space Repetition 0.5 is the center of repetition

          // // Boxes
          float boxSize = 1.0;
          float box = sdBox(q * 4.0, vec3(0.25)) / 4.0;

          // Streets and Parkways, Create building SDF and place it on street
          // Use mod(p.x, grid_size) and mod(p.z, grid_size) for infinite grid layout
          float grid_size = 15.0;  // Grid spacing for streets & buildings
          float road_width = 2.5;  // Adjust road width

          // Calculate building's position based on street number
          float buildingHeight = 3.0 + noise(p.xz * 0.1) * 2.0; // Random building height
          vec3 buildingPos = q - vec3(mod(q.x, grid_size), 0.0, mod(q.z, grid_size));
          float building = sdBuilding(buildingPos * 3.0, vec3(boxSize, buildingHeight, boxSize * 3.0) / 3.0) / 3.0;  // Generate a unique "houseNumber" based on the building's grid position

          // Use hash function to introduce randomness for building properties based on the houseNumber
          float houseNumber = floor(buildingPos.x / grid_size) + floor(buildingPos.z / grid_size) * 57.0;  // Unique ID for each building
          float heightFactor = hash(houseNumber + 1.0); // Random value for height variation
          float sizeFactor = hash(houseNumber + 2.0);   // Random value for size variation

          // Apply these random values to alter building height and size
          buildingHeight += heightFactor * 2.0; // Alter height based on houseNumber
          boxSize += sizeFactor * 0.5;          // Alter size based on houseNumber

          // Combine the ground with buildings
          float terrain = min(ground, building);  

          // Combine ground with buildings using smooth union
          // return opSmoothUnion(ground, building, min(min(box, building), terrain));
          return opSmoothUnion(terrain, building, smin(min(box, building), terrain, 2.0));
          //return smin(terrain, building, smin(min(box, building), terrain, 2.0));
        }

        float sdFlowers(vec3 p) {
          float t = 0.01;
          float u = 0.001 + time;
          float v = 0.001 + (0.1 * time);
          float m = (0.088 + v)+ (time * t);

          float r = length(p)*2.0;
          float a = atan(atan(p.y,p.x), p.z);
      
          float f = cos(a*3.);
          // f = abs(cos(a*3.));
          // f = abs(cos(a*2.5))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

          float sh = smoothstep(f, f + 0.02, r);
      
          float shape = 1.0 - sh;

          return shape;
        }

        float sdFlowerVortex(vec3 p) {
          float t = 0.01;
          float u = 0.001 + time;
          float v = 0.001 + (0.1 * time);
          float m = (0.088 + v)+ (time * t);

          float r = length(p)*2.0;
          float a = atan(atan(p.y,p.x), p.z);
      
          float f = cos(a*3.);
          // f = abs(cos(a*3.));
          // f = abs(cos(a*2.5))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

          float smh = smoothstep(f, f + 0.02, r);
      
          float shape = 1.0 - smh;

          return shape;
        }

        float dragonSpider(vec3 p) {
          vec2 drg = p.xz;
          float r = length(drg) * 2.616;
          float a = fract(atan(drg.y * p.z, fract(drg.x) - 0.2 * sin(drg.x * drg.y * p.z))) - r;
        
          float f = abs(cos(a * 2.5)) * 0.5 + 0.3;
          f = abs(cos(a * 12.0) * sin(a * 3.0)) * 0.8 + 0.1;
          float softness = smoothstep(-0.5, 1.0, cos(a * 10.0)) * 0.2 + 0.5;
        
          float d = 1.0 - smoothstep(f, sin(f + r) - 0.25, r);
          return d - 0.5;
        }

        float sdWaspDagon(vec3 p, float r, float t) {
          r = length(p) * 2.616;
          float a = fract(atan(p.y * p.z, fract(p.x * sin(t * p.z)) - 0.2 * p.z + t)) - r;
        
          t += fract(time * 0.25 * p.z);
          float wave = sin(a * 10.0 + t * 6.2831); // 2Ï€ loop
          float f = abs(wave * p.z) * 0.8 + 0.1;
        
          float softness = smoothstep(-0.5, 1.0, cos(a * 10.0)) * 0.2 + 0.5;
          float waspDagon = 1.0 - smoothstep(f, sin(f + r + t) - 0.25, r);
        
          return waspDagon;
        }        

        float sdDragonWingedSpider(vec3 p, float wings, float tails) {
          vec2 drg = p.xz;
          float r = length(drg) * 2.616;
          float a = fract(atan(drg.y * p.z, fract(drg.x) - 0.2 * sin(drg.x * drg.y * p.z))) - r;
        
          float f = abs(cos(a * 2.5 * sqrt(wings))) * 0.5 + 0.3;
          f = abs(cos(a * 12.0) * sin(a * 3.0)) * 0.8 + 0.1;
          float softness = smoothstep(-0.5, 1.0, cos(a * 10.0 + sqrt(wings + tails))) * 0.2 + 0.5 + tails;
        
          float dragonWingedSpider = 1.0 - smoothstep(f, sin(f + r) - 0.25, r);
          return dragonWingedSpider - 0.5;
        }
        
        float waspSpider(vec3 p) {
          vec2 proj = p.xz;
          float r = length(proj) * 2.616;
          float a = fract(atan(proj.y, fract(proj.x) - 0.2)) - r;
        
          float f = abs(cos(a * 12.0) * sin(a * 3.0)) * 0.8 + 0.1;
          float sh = smoothstep(f, sin(f + r) - 0.25, r);
          float spider =  1.0 - sh;
          return spider;
        }

        float waterFront(vec3 p) {
          float t = 0.01;
          float u = 0.001 + time;
          float v = 0.001 + (0.1 * time);
          float m = (0.088 + v)+ (time * t);

          // vec2 pos = vec2(0.5)-uv;
          // float r = length(p)*2.0;
          // float a = atan(p.y,(p.x));
          // a = atan(u, fract(v + r)) - r;
      
          // float f = cos(a*(3.0 + m));
          // // f = abs(cos(a*3.));
          // // f = abs(cos(a*(2.5+ m)))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*(3. + u)+ time))*.8+.1;
          // f = abs(cos(a*12.)*tan(a*(3. + u)+ time))*.8+.1;

          float r = length(p)*2.0;
          float a = atan(atan(p.y, p.z),(p.x * p.z));
          a = atan(u, fract(v + r)) - r;
          a = atan(fract(p.y * p.z) - 0.2 * cos(p.x * p.z), sin(p.z * p.y));

          float f = cos(a*(3.0 + m));
          // f = abs(cos(a*3.));
          // f = abs(cos(a*(2.5+ m)))*.5+.3;
          f = abs(cos(a*12.)*sin(a*(3. + u)+ time))*.8+.1;
          f = abs(cos(a*12.)*tan(a*(3. + u)+ time))*.8+.1;
          float waterFront = 1.-smoothstep(f,f+0.02,r);
          return waterFront;
        }

        float blendedMosaic(vec3 p, float r, float h){
            r *= length(p)*2.0;
            h *= atan(
              p.y, 
              atan(
                p.z, 
                fract(p.y)
              ))*length(p)*2.816;
            float a = atan(p.y,p.x * sin(fract(p.x * time)));
            float v = atan(p.y, p.y * p.z) / sqrt(a);
            float avb = fract(atan(v * p.z * p.y, fract(p.y + smoothstep(p.x, sin(0.3 *(time) ), p.x*p.z)) - 0.2 * sin(p.x * p.y))) - r;
            a += avb;
            float bf = -0.176; //+ (time * 0.001);
            float f = cos(a*3.);
            f = smoothstep(-0.5, 1.0, cos(a * 10.200 * atan(p.x + sin(time), fract(a * time)))) * (bf) + 0.5;
            // f = abs(cos(a*3.));
            // f = abs(cos(a*2.5))*.5+.3;
            // f += abs(cos(a*12.)*sin(a*3.))*.8+.1;
            // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
        
            float mosaic =  1.-smoothstep(f,f+0.02,r);
            return mosaic;
        }
        
        float duckSpring(vec3 p, float r, float h){
            r *= length(p)*2.0;
            h *= atan(
              p.y * p.z, 
              atan(
                p.z, 
                fract(p.y)
              )
            )*length(p)*2.816;
            float a = atan(p.y,p.x);
            float m = 0.001 * p.z;
            float mn = 0.01 * time;
            float gt = m * pow(h*m, time) + mn;
            float gh = h *cos(a*(3.088 + gt) + (time* p.z));
            vec3 v = vec3(atan(p.y, p.x * p.z));
            a *= sqrt(fract(min(a,smoothstep(a, gt, gh)))) ;
        
            float f = cos(v.z*a*3.688)*-r - sin(2.+a * gh * p.z + time)*2.200+.1;
            f += fract(a* gh * v.z + time);
            // f += min(f, gh);
            
            // f = abs(cos(a*2.264));//Duck//
            // f = abs(cos(a*2.5))*.5+.3;// Bird
            // f = abs(cos(a*12.192)*sin(a*3.))*.8+.1;// Butterfly
            // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
        
            float duck = 1.-smoothstep(f,f+0.02,r);
            return duck;
          }
        
        
        float sandySpring(vec3 p, float r, float h){
            r *= length(p)*2.0;
            h *= atan(
              p.y * p.z, 
              atan(
                p.z, 
                fract(p.y)
              ))*length(p)*2.816;
            float a = atan(p.y,p.x);
            float m = 0.001 * p.z;
            float mn = 0.01 * time;
            float gt = m * pow(h*m, time) + mn;
            float gh = h *cos(a*(3.088 + gt) + ((time) * p.z));
            vec3 v = vec3(atan(p.y,p.x* p.z));
            a /= min(a,smoothstep(a, gt, gh));
        
            float f = cos(a*3.688)*-r - sin(2.+a * gh * p.z + time)*2.200+.1;
            f += fract(a* gh * v.z + time); // SandySprings
            // f += min(f, gh);
            
            // f = abs(cos(a*3.));// SandOrbits
            // f = abs(cos(a*2.5))*.5+.3;//
            // f = abs(cos(a*12.)*sin(a*3.))*.8+.1; //SandyPlane
            // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;//SandWorld
            return 1.-smoothstep(f,f+0.02,r);
          }
        
        
        float sandPlain(vec3 p, float r, float h){
            r *= length(p)*2.0;
            h *= 
            atan(
              p.y * p.z, 
              atan(
                p.z, 
                fract(p.y)
              )
            )*length(p)*2.816;
            float a = atan(p.y,p.x);
            float v = atan(p.y, p.x * p.z);
            float m = 0.001 * p.z;
            float mn = 0.01 * time;
            float gt = m * pow(h*m, time) + mn;
            float gh = h *cos(a*(3.088 + gt) + ((time) * p.z));
            a = min(a,gh) ;

            float f = cos(a*3.688)*-r - sin(2.+a * gh * p.z + time)*2.200+.1;
            f += fract(a* gh * p.z + time);
            // f += min(f, gh);
            
            // f = abs(cos(a*3.));
            // f = abs(cos(a*2.5))*.5+.3;
            // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
            // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
        
            float plane = 1.-smoothstep(f,f+0.02,r);
            return plane;
        }

        vec3 rollingBug(vec2 u) {
          vec3 p = vec3(0.0, 0.0, -9.0 * time);
        
          vec2 pos = vec2(0.5)-u;
        
          float xs = 0.001 * time;
          float sm = 0.01 * time;
            
          float r = length(pos)*2.0;
          float smr = smoothstep(r* tan(pow(pos.x, pos.y)), r+pos.x, atan(tan(r * sm), pos.y));
          float h = sin(r) * sin(smr);
          float a = atan(pos.y,pos.x) - smr;
          float pol = atan(pos.y,pos.x) - smr *h;
          float cyc = atan(pos.y,pos.x) - smr -h *a;

          pol *= atan(cyc, pol);// Horse Runner
          // a  = atan(pos.y,pos.x) - smr - (time + tan(pos.y)); wheel circus
          a += pol; // Dirty Bug
          a *= pol; //* sqrt(a * time); // Dirty Bug
          // a = pol; //* sqrt(a * time); // Motion Flower

          float csn = a*pol;
          a += csn * fract (sin(a* p.z *time) ) + time;
 
          float rollMill = a + (csn * fract (sin(a* p.z *time) ) + time);
          // float fan = a + (csn * fract (sin(a+ p.z *time) ) + time);
          // a = fan;
          // a = rollMill;

          float ac = cos(cyc-a*3.+ pow(cyc, pol)) / pol * csn;
          float ad = sin(cyc-a*3.+ pow(cyc, pol));
          float f = ad - cos(a*3.+ pow(cyc * tan(0.6), pol)) * 21.976*(ad / pol) * csn;

          f = min(ad,ac+tan(pol* 13.0));
          // f = abs(cos(a*3.));
          // f = abs(sin(a*2.5))*0.652+.3;
          // f = abs(cos(a*12.)*sin(a*3.296))*0.904+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.264+0.580;
        
          return vec3( 1.-smoothstep(f,f+0.02,r) );
        }

        float mapDragons(vec3 p) {
          // Base ground
          float ground = sdfGround(p);
        
          // Infinite tiling
          vec3 q = p;
          q.z += time * 0.4;
          q.y -= time * 0.4;
          q = fract(q) - 0.5;
        
          // DRAGON SPIDER CREATURE
          float dragonSpiders = dragonSpider(q * 4.0);
        
          // Grid setup
          float grid_size = 15.0;
          float road_width = 2.5;
        
          // WASP-DRAGON MOBILITY OFFSET
          vec2 waspTile = floor(q.xz / grid_size);
          float waspSeed = hash(dot(waspTile, vec2(7.3, 5.1))); // unique per tile
          vec3 waspWiggle = vec3(
            sin(time * 0.8 + waspSeed * 3.0),
            cos(time * 0.6 + waspSeed * 5.0),
            sin(time * 0.4 + waspSeed * 7.0)
          ) * 1.5;

          float waspSize = 3.0 + noise(p.xy * 0.1) * 2.0;
          float waspTail = q.x * time;
          vec3 waspOffset = vec3(mod(q.x * 0.02, grid_size), road_width, mod(q.z, grid_size));
          vec3 waspPos = q - waspOffset + waspWiggle;
          float waspDragon = sdWaspDagon(q - waspPos * 3.0,  waspSize, waspTail);
        
          // DRAGON DISTRIBUTION + WIGGLE
          vec2 dragonTile = floor(q.xz / grid_size);
          float dragonSeed = hash(dot(dragonTile, vec2(3.1, 8.2)));
          vec3 dragonWiggle = vec3(
            cos(time * 0.6 + dragonSeed * 10.0),
            sin(time * 0.4 + dragonSeed * 6.0),
            cos(time * 0.5 + dragonSeed * 4.0)
          ) * 1.8;
        
          float dragonTail = time * q.z;
          float dragonSize = S(time * q.z);
          float tailFactor = hash(dragonTail + 1.0);
          float sizeFactor = hash(dragonSize + tan(q.z) + 0.002);
          dragonSize += tailFactor * 2.0;
          waspSize += sizeFactor * 0.5;
        
          vec3 dragonPos = vec3(
            floor(q.x / grid_size) * grid_size,
            0.0,
            floor(q.z / grid_size) * grid_size
          ) + dragonWiggle;
        
          float dragonWingedSpider = sdDragonWingedSpider(q - dragonPos, dragonTail, dragonSize);
        
          // FINAL BLEND
          float springCreatures = min(dragonWingedSpider, waspDragon);
          float springDragons = smin(springCreatures, dragonSpiders, 0.4);
        
          // ðŸŒ TERRAIN MAP
          float terrain = mapTerrain(p);

          // ðŸŒˆ Final World Blend
          return smin(terrain, springDragons, 0.3);
        }

        // Light
        vec3 computeLighting(vec3 p, vec3 normal, vec3 lightPos, vec3 viewDir, float shadow) {
          vec3 lightDir = normalize(lightPos - p);
      
          // Compute soft shadow
          // float shadow = softShadow(p + normal * 0.02, lightDir, 0.1, 10.0, 16.0);
          
          // Diffuse lighting
          float diff = max(dot(normal, lightDir), 0.0);
          
          // Specular lighting (Phong reflection)
          vec3 halfVec = normalize(lightDir + viewDir);
          float spec = pow(max(dot(normal, halfVec), 0.0), 32.0);
          
          // Combine lighting and shadow
          vec3 color = vec3(1.0, 0.9, 0.7); // Light color
          return (diff + spec) * color * shadow;
        }

        void wiggleCamera(inout vec3 ro, inout vec3 rd, vec2 uv, vec2 mouse, float time) {
          // Adding wiggle effect to the camera
          ro.x += sin(time * 2.0) * 0.5;
          ro.y += cos(time * 1.5) * 0.2;
          
          // Slight noise-based distortion on ray direction
          rd += normalize(vec3(
              sin(uv.x * time * 0.5) * 0.1,  
              cos(uv.y * time * 0.3) * 0.1,  
              sin(uv.x * time * 0.7) * 0.1  
          ));

          rd = normalize(rd); // Normalize direction after adding noise

          // Camera rotations
          ro.yz *= rot2D(-mouse.y);
          rd.yz *= rot2D(-mouse.y);

          ro.xz *= rot2D(-mouse.x);
          rd.xz *= rot2D(-mouse.x);
        }

        // Optional Shadow calculator
        float computeShadow(vec3 p, vec3 lightPos) {
          vec3 shadowDir = normalize(lightPos - p);
          float shadowT = 0.1; // Small offset to avoid self-shadowing
          float shadowFactor = 1.0; // Default: no shadow
      
          for (int j = 0; j < 10; j++) { // Optimized iteration count
              vec3 shadowPoint = p + shadowDir * shadowT;
              float shadowDist = mapTerrain(shadowPoint);
      
              if (shadowDist < 0.001) {
                  shadowFactor = 0.5; // In shadow
                  break;
              }
      
              shadowT += shadowDist;
              if (shadowT > 5.0) break; // Exit if ray goes too far
          }
          return shadowFactor;
        }

        // Function to compute soft shadows
        float computeSoftShadow(vec3 p, vec3 lightPos) {
          vec3 shadowDir = normalize(lightPos - p);
          float shadowT = 0.1; // Small initial offset to avoid self-shadowing
          float shadowFactor = 1.0;
          float maxDist = 5.0;

          for (int j = 0; j < 24; j++) { // Optimized loop count
            vec3 shadowPoint = p + shadowDir * shadowT;
            float shadowDist = mapTerrain(shadowPoint);
                
            if (shadowDist < 0.001) {
              shadowFactor *= 0.5; // Reduce intensity for occlusion
            }
                
            shadowT += shadowDist * 0.5; // Smaller steps improve softness
            if (shadowT > maxDist) break; // Stop marching if too far
          }

          return clamp(shadowFactor, 0.2, 1.0); // Ensure valid shadow range
        }

        // Display Shadows
        float computeHardShadow(vec3 ro, vec3 lightPos) {
          vec3 shadowRayDir = normalize(lightPos - ro);
          float shadowT = 0.0;
          float shadowIntensity = 1.0;
      
          for (int i = 0; i < 20; i++) {
              vec3 shadowPoint = ro + shadowRayDir * shadowT;
              float shadowDist = mapTerrain(shadowPoint);
              shadowT += shadowDist;
      
              if (shadowDist < 0.001) {
                  shadowIntensity = 0.5; // Shadowed region
                  break;
              }
          }
      
          return shadowIntensity;
        }

        vec3 computeNormal(vec3 p) {
          float epsilon = 0.001;
          return normalize(vec3(
              mapTerrain(p + vec3(epsilon, 0, 0)) - mapTerrain(p - vec3(epsilon, 0, 0)),
              mapTerrain(p + vec3(0, epsilon, 0)) - mapTerrain(p - vec3(0, epsilon, 0)),
              mapTerrain(p + vec3(0, 0, epsilon)) - mapTerrain(p - vec3(0, 0, epsilon))
          ));
        }

        vec3 applyFog(vec3 color, float distance, vec3 fogColor, float fogDensity) {
          float fogFactor = exp(-distance * fogDensity); // Exponential fog
          return mix(fogColor, color, fogFactor); // Blend fog with scene color
        }
      
        // Ripple Utilities
        vec3 applyFloatRipple(float x, float y, float z, float d) {
          float ripple = sin(10.0 * d - time * 5.0);
          float intensity = smoothstep(0.3, 0.0, d);

          vec3 wave = vec3(x, y, z) + ripple * intensity;
          return wave;
        }

        vec3 applyRipple(vec3 p, float d, float time) {
            float ripple = sin(10.0 * d - time * 5.0);
            float intensity = smoothstep(0.3, 0.0, d);
            return p + normalize(vec3(p.xy, 0.0)) * ripple * intensity;
        }
        
        vec3 applyTurboRipple(vec3 position, float dist, float time, float frequency, float speed, float fade) {
          float ripple = sin(frequency * dist - time * speed);
          float intensity = smoothstep(fade, 0.0, dist);
          return position + normalize(vec3(position.xy, 0.0)) * ripple * intensity;
        }
      
        float blendShapeFactor(float uvx, float factor, float timeMod) {
          float raw = fract(factor * uvx);
          float st = smoothstep(0.0, 1.0, raw); // or your custom S()
          float animated = st * sin(timeMod + uvx * factor);
          return animated;
        }

        vec3 computeCameraTubePosition(float time) {
          float radius = 5.0;  // Adjust radius for left/right swing
          float speed = 0.5;   // Rotation speed
          float camX = radius * sin(time * speed);  // Left/Right movement
          float camZ = -time * 3.0;  // Forward movement into the tunnel

          // float camX = radius * sin(time * speed);
          // float camY = cos(time * 0.4) * 0.5;  // Small up/down motion
          // float camZ = -time * (2.5 + sin(time * 0.2) * 1.5); // Smooth speed variation  
          // return vec3(camX, camY, camZ);
          return vec3(camX, 0.5, camZ);  // Keep Y constant
        }
      
        vec3 computeCameraPosition(float time) {
          float radius = 5.0; // Adjust for larger or smaller movement
          float speed = 0.5; // Adjust rotation speed
      
          float camX = radius * cos(time * speed);
          float camZ = radius * sin(time * speed);
          
          return vec3(camX, 1.5, camZ - 3.0); // Y-position can be adjusted for height
        }

        mat2 scale(vec2 _scale){
            return mat2(_scale.x,0.0,
                        0.0,_scale.y);
        }
        
        float rollinBox(in vec2 u, in vec2 s){
          s = vec2(0.5) - s*0.5;
          vec2 suv = smoothstep(
            s,
            s+vec2(0.001),
            u
          );
          suv *= smoothstep(
            s,
            s+vec2(0.001),
            vec2(1.0)-u
          );
          return suv.x*suv.y;
        }
                
        float ripple(vec2 uv, float t) {
          float dist = length(uv - 0.5);
          float wave = sin(20.0 * dist - t * 5.0);
          return smoothstep(0.01, 0.015, wave);
        }

        float scanline(vec2 uv, float t) {
          float y = fract(t * 0.2);
          return smoothstep(y - 0.01, y, uv.y) - smoothstep(y, y + 0.01, uv.y);
        }

        float fractilize(float f, float t) {
          float st = sin(pow(f, t));
          float smh = S(smoothstep(st + f, t, st));
          float tx = fract(fract(st) + smh);
          return tx;
        }
      
        // Smoothstep interpolation function for blending
        float smoothTime(float t) {
          float u = t * t * (3.0 - 2.0 * t); // Standard smoothstep easing
          float blend = smoothstep(
            S(u + (t *  time)), 
            sqrt(u + sin(t * time)), 
            sqrt(u)
          );
          return blend;
        }

        float smoothFloatTime(float t) {
          float u = t * t * (3.0 - 2.0 * t);
          float a = u;
          float b = u + sin(t * 1.5);
          float x = sqrt(u);
          return smoothstep(a, b, x);
        }
        
        // Smoothstep interpolation function for blending
        float blendView(vec3 p, float t) {
          float u = sin(t * t * (3.0 - 2.0 * t));
          float v = pow(t, u);
          float mv = fract(v);
          float s = sdSphere(p, smoothTime(mv));
          float blend = smoothstep(
            S(time * (t + mv)), 
            S(pow(u, sin(t + u))), 
            s
          );

          return blend * sqrt(blend * time);
        }

        vec3 colorPallete(vec3 p, vec3 color, vec2 u, vec2 m, float shadowIntensity, float rayPower) {
          float redBlend = blendView(p, fract(dragonSpider(p * time)));
          float blueButter = shadowIntensity + rayPower + S(noise(u.xy * 2.0 + time * 0.7)) * shadowIntensity;
          float bt = smoothTime(blueButter + time);
          float greenMoney = smoothstep(bt, sin(time + bt), sqrt(time + u.x));
          float rgR = smoothstep(shadowIntensity, (rayPower + S(noise(u.xy * 4.0 + time * 0.3)) ), shadowIntensity); 
          float rgG = sqrt(shadowIntensity + rayPower + S(noise(u.yx * 3.0 + time * 0.5)) * smoothTime(shadowIntensity));
          float rgB = smoothTime(blueButter + time);
          vec3 colorBlend = vec3(rgR, rgG, rgB);
          vec3 colorDust = vec3(smoothTime(redBlend), time + m.x, sqrt(redBlend));
          vec3 colorButter = mix(colorBlend, colorDust, redBlend * blueButter);
  
          return mix(smoothstep(color, colorDust, colorButter), colorBlend, smoothstep(redBlend, blueButter, greenMoney));
        }
  
        
        float dancingSpider(vec3 p, vec2 u) {
          vec2 pos = vec2(0.5)-u;
          p += vec3(0.0, 0.0, -9.0 );
      
          float r = length(pos)*2.0;
          float h = atan(
                    sin(pos.y * tan(r + p.z + (sin(3. * time)) ) * sin(p.z * time)), 
                    atan(
                      p.z, 
                      fract(pos.y * r)
                    )
                  )*length(p)*2.888;
      
          float a = atan(pos.y,pos.x) * h;// * time;
          float m = 0.001 * p.z;
          float mn = 0.01 * time;
          float gt = m * pow(h*m, time) + mn;
          float gh = h *cos(a*(3.088 + gt) + ((time) * p.z));
                  vec3 v = vec3(atan(p.y,p.x* p.z));
      
          float f = cos(a*3.);
          f = cos(a*3.*-1.680)+ (0.412+ sin(a*0.2)) -r;
          // f = abs(cos(a*3.));
          // f = abs(cos(a*2.5))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
          return 1.-smoothstep(f,f+0.02,r) ;
        }

        float bouncingSpider(vec3 p, vec2 u) {
          vec2 pos = vec2(0.5)-u;
          p += vec3(0.0, 0.0, -9.0 );

          float r = length(pos)*2.0;
          float h = atan(
                    sin(pos.y * tan(r + p.z + (sin(3. * time)) ) * sin(p.z * time)), 
                    atan(
                      p.z * r, 
                      fract(pos.y * r)
                    )
                  )*length(p)*.888;

          float a = atan(pos.y,pos.x) * h;// * time;
          float m = 0.001 * p.z;
          float mn = 0.01 * time;
          float gt = m * pow(h*m, time) + mn;
          float gh = h *cos(a*(3.088 + gt) + ((time) * p.z));
                  vec3 v = vec3(atan(p.y,p.x* p.z));

          float f = cos(a*3.);
          f = cos(h*a*3.*-1.680)+ (0.412+ sin(a*-0.592)) -r;
          // f = abs(cos(a*3.));
          // f = abs(cos(a*2.5))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

          float spider =  1.-smoothstep(f,f+0.02,r);
          return spider;  
        }

        float whiteSpider(vec3 p, vec2 u) {
          vec2 pos = vec2(0.5)-u;
          p += vec3(0.0, 0.0, -9.0);

          float r = length(pos)*2.0;
          float h = atan(
                    pos.y * p.z, 
                    atan(
                      p.z, 
                      fract(pos.y)
                    )
                  )*length(p)*2.816;

          float a = atan(pos.y,pos.x) * h;

          float f = cos(a*3.);
          f = cos(a*3.*-1.680)+ (0.412+ sin(a*0.2)) -r;
          // f = abs(cos(a*3.));
          // f = abs(cos(a*2.5))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

          return  1.-smoothstep(f,f+0.02,r);
        }

        void main() {
          // UV Mapping
          vec2 fragCoord = gl_FragCoord.xy;
          vec2 uv = fragCoord / resolution; // Proper UV mapping
          uv.x *= resolution.x / resolution.y;

          // Normalize Mouse normalized to same space (assuming it's passed in already as [0, res])
          vec2 mouse = (mousePosition * 2.0 - 1.0); // Convert to [-1, 1] range// either works
          vec3 color = vec3(0.0);
          float spider = whiteSpider(vec3(mouse*uv, -time * 8.0), uv);
          vec3 dragon = vec3(dragonSpider(color)) * spider;
          vec3 colorObj = colorPallete(vec3(uv, spider), dragon, uv, mouse, mouse.x, spider);
  
          // // Aspect ratio correction for final rendering only, not for distance
          // vec2 aspectUV = uv;
          // aspectUV.x *= resolution.x / resolution.y;
          // // Center and scale position
          // vec2 p = vec2(0.55, 0.54) - uv;
      
          // // Call your effect function
          color += vec3(spider);
          vec3 mc = mix(dragon, colorObj, spider);
          color = mix(color, vec3(uv * mouse, spider), uv.x * time);
  
          // Check if hovered is active or not
          float absT =  abs(sin(time));
          if (hovered > 0.0) {
            // Mouse is hovering, apply mouse interaction effects
            float dist = distance(mouse, uv);
            // dist +=  absT;
  
            // Use the distance to influence the color (make mouse position cause a color shift)
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Makes the area closer to the mouse lighter (for visible effect)
  
            // Use distance to control the opacity
            float opacity = smoothstep(0.0, 0.5, dist); // Opacity decreases with distance from the mouse position
  
            // Optionally, add time-based animation for extra dynamics
            color *= 0.5 + 0.5 * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and time
            // vec3 colorPallete = mix(color, colorBlend, smoothstep(redBlend, blueButter, greenMon
            color += mix(color, colorObj, time);//fract( * absT); //, sin(dist * (uv.x + time)));
  
            gl_FragColor = vec4(color, opacity);
          } else {
            // Mouse is not hovering, apply default effect based on UV coordinates and distance
            float dist = distance(uv, vec2(0.5, 0.5)); // Default base distance, could be replaced with your original calculation
            color += vec3(1.0 - dist, 1.0 - dist, 1.0); // Use original UV-distance-based coloring
            color *= 0.5 + 0.5 * sin(time + dist * 10.0); // Add a dynamic oscillating effect based on distance and time
            // vec3 colorObj = mix(color, colorBlend, smoothstep(redBlend, blueButter, greenMoney));
            color += mix(color, colorObj, absT);
            float opacity = smoothstep(0.6, 0.8, 1.0);
            gl_FragColor = vec4(color, opacity); // Default behavior
          }

          // gl_FragColor = vec4(color, 1.0);
        }
      
      `
    }
        
        vec3 sandyLandScape(vec3 p, vec2 u) {
          vec2 pos = vec2(0.5)-u;
          p += vec3(0.0, 0.0, -9.0 );
      
          float r = length(pos)*2.0;
          float h = atan(
                    sin(pos.y * tan(r + p.z + (sin(3. * time)) ) * sin(p.z * time)), 
                    atan(
                      p.z, 
                      fract(pos.y * r)
                    )
                  )*length(p)*2.888;
      
          float a = atan(pos.y,pos.x) * h * .12;// * time;
          float m = 0.001 * p.z;
          float mn = 0.01 * time;
          float gt = m * pow(h*m, time) + mn;
          float gh = h *cos(a*(3.088 + gt) + ((time) * p.z));
                  vec3 v = vec3(atan(p.y,p.x* p.z));
      
          float f = cos(a*3.);
          f = cos(a*3.*-1.680)+ (0.412+ sin(a*0.2)) -r*gh;
          // f = abs(cos(a*3.));
          // f = abs(cos(a*2.5))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
          float landscape = 1.-smoothstep(f,f+0.02,r) ;
          vec3 shape = vec3(landscape, a, h);
        }




float sdSnake(vec3 p, vec2 a, float h) {
    vec3 q = abs(p) - (a.x * a.y * h); 
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}
        
        float dancingSpider(vec3 p, vec2 u) {
          vec2 pos = vec2(0.5)-u;
          p += vec3(0.0, 0.0, -9.0 );
      
          float r = length(pos)*2.0;
          float h = atan(
                    sin(pos.y * tan(r + p.z + (sin(3. * time)) ) * sin(p.z * time)), 
                    atan(
                      p.z, 
                      fract(pos.y * r)
                    )
                  )*length(p)*2.888;
      
          float a = atan(pos.y,pos.x) * h * .12;// * time;
          float m = 0.001 * p.z;
          float mn = 0.01 * time;
          float gt = m * pow(h*m, time) + mn;
          float gh = h *cos(a*(3.088 + gt) + ((time) * p.z));
                  vec3 v = vec3(atan(p.y,p.x* p.z));
      
          float f = cos(a*3.);
          f = cos(a*3.*-1.680)+ (0.412+ sin(a*0.2)) -r*gh;
          // f = abs(cos(a*3.));
          // f = abs(cos(a*2.5))*.5+.3;
          // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
          // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;
          return 1.-smoothstep(f,f+0.02,r) ;
        }



        // Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

float hash(float n) {
    return fract(sin(n) * 43758.5453);
}

float noise(float x) {
    float i = floor(x);
    float f = fract(x);
    float u = f*f*(3.0-2.0*f);
    return mix(hash(i), hash(i+1.0), u);
}

// Digit-based angle term (e.g., spinning/oscillation)
float at(float n, vec2 pos) {
    float base = pow(10.0, - n);
    return atan(pos.y, pos.x) * base;
}

// Digit-based position term
float pt(float n, vec3 p, float time) {
    float base = pow(10.0, -n);
    return base * length(p) * sin(time * base);
}

float gp(float a, float r, float n) {
    float progression = a * pow(r, (n - 1.0));
    return progression;
}

// Digit-based growth term
float gt(int n, float h, float pz, float time) {
    float base = pow(10.0, -float(n)); // Scale for target decimal
    float amp = base * pz; // Positional influence
    float osc = base * sin(time * 2.0); // Oscillating offset
    return amp * pow(h * amp, time) + osc;
}

float euler(float t, float rate, float decay) {
    return exp(-decay * t) * sin(rate * t);
}

float multiplyDecimalPlace(float base, float place, float magnitude) {
    float delta = pow(10.0, - place) * magnitude;
    return base + delta;
}
    // float result = shiftDigit(0.12345, 3, 7.0); // change 3rd decimal by 7 â†’ 0.12345 + 0.007 = 0.13045
float computeDigitStep(float decimalPlace, float multiplier) {
    return pow(10.0, - decimalPlace) * multiplier;
}

float oscillateDigitStep(float base, int place, float freq, float time) {
    float amp = pow(10.0, -float(place));
    return base + amp * sin(time * freq);
}

// Smoothed precision step
float smoothDigitStep(float base, float place, float magnitude) {
    float delta = pow(10.0, -place) * magnitude;
    float t = smoothstep(0.0, 1.0, fract(u_time)); // smooth transition over 1 second
    return mix(base, base + delta, t);
}

float bounce(float t, float freq, float scale) {
    return abs(sin(t * freq)) * scale;
}

float randomOsc(float t, float freq, float seed) {
    return fract(sin(t * freq + seed) * 43758.5453);
}
/* //Combine with mix():
float offset = mix(0.0, pow(10.0, -3.0), bounce(u_time, 2.0, 1.0));
*/

float organicMotion(vec3 p, float t) {
    return noise(p.x *(p.y *sin(p.x * p.z))* 0.1* t * 0.2) * 0.005;
}

vec3 computeDistribution(float p, float h) {// Digit-specific precise multipliers
    float m = pow(10.0, -3.0) * p;       // 0.001 * p.z with full precision
    float mn = pow(10.0, -2.0) * u_time;     // 0.01 * time with full precision

    // Optional: Even more dynamic control
    float growthRate = pow(10.0, -3.0);    // fine-tuned growth per frame
    float gt = m * pow(h * m, u_time) + mn + growthRate * sin(u_time * 2.0);

    vec3 distribution = vec3(m, mn, gt);
    return distribution;
}
/* and this slider method looks wierd, no body or retrun
uniform float u_precision; // range 1.0 to 4.0
int n = int(u_precision);
*/
float gaussian(float x, float mean, float sigma) {
    return (1.0 / (sigma * sqrt(6.2831))) * exp(-pow(x - mean, 2.0) / (2.0 * sigma * sigma));
}

// Primes up to the 16th (more if needed)
float getPrime(int index) {
    if (index == 0) return 2.0;
    if (index == 1) return 3.0;
    if (index == 2) return 5.0;
    if (index == 3) return 7.0;
    if (index == 4) return 11.0;
    if (index == 5) return 13.0;
    if (index == 6) return 17.0;
    if (index == 7) return 19.0;
    if (index == 8) return 23.0;
    if (index == 9) return 29.0;
    return 31.0; // default if index too high
}

//float pTime = primeModTime(4); // time / 11.0
float primeModTime(int index) {
    return u_time * (1.0 / getPrime(index));
}

float fadePrimeTime(int n){
    float mixTime = mix(
        primeModTime(n+2), 
        primeModTime(n+5), 
        sin(u_time * 0.1) * 0.5 + 0.5
    );
    return mixTime;
}

vec3 colorTime() {
    float r = 0.5 + 0.5 * sin(u_time);
    float g = 0.5 + 0.5 * sin(u_time + 2.0);
    float b = 0.5 + 0.5 * sin(u_time + 4.0);
    vec3 pallete = vec3(r, g, b);
    return pallete;
}

void main(){
    vec2 uv = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    vec2 pos = vec2(0.5)-uv;

    float r = length(pos)*2.0;
    float a = atan(pos.y,pos.x);

    float f = cos(a*3.);
    // f = abs(cos(a*3.));
    // f = abs(cos(a*2.5))*.5+.3;
    // f = abs(cos(a*12.)*sin(a*3.))*.8+.1;
    // f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;

    color = vec3( 1.-smoothstep(f,f+0.02,r) );

    gl_FragColor = vec4(color, 1.0);
}

